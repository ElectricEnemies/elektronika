/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//	QThelpers.CPP				(c)	YoY'05						WEB: www.aestesis.org
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include <math.h>
#include <stdarg.h>
#include <assert.h>
#include "QThelpers.h"
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#if 0
static void dbgprint(char *format, ... )
{
   va_list	marker;
   char		str[256];

   va_start(marker, format );     /* Initialize variable arguments. */
   sprintf(str, format, marker);
   {
	   FILE *f=fopen("d:\\qtdbg.txt", "a");
	   if(f)
	   {
			fprintf(f, str);
			fclose(f);
	   }
   }
   va_end( marker );              /* Reset variable arguments.      */
}
#else
static void dbgprint(char *format, ... )
{
}
#endif

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static AquickTime * getAqt(Movie movie)
{
	int i;
	for(i=0; i<MAXQTMOVIE; i++)
	{
		if(qtHost.qt[i]&&qtHost.qt[i]->theMovie==movie)
			return qtHost.qt[i];
	}
	assert(false);
	return NULL;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

__inline wide qword2wide(qword a)
{
	wide n;
	n.hi=(SInt32)(a>>32);
	n.lo=(UInt32)(a&0xFFFFFFFF);
	return n;
}

__inline qword wide2qword(wide w)
{
	return (((qword)w.hi)<<32)|w.lo;
}

static void setLoop(MovieController player, Movie movie, double begin, double end)
{
	qword max=GetMovieDuration(movie);
	TimeRecord tr;
	tr.base=GetMovieTimeBase(movie);
	tr.scale=GetMovieTimeScale(movie);
	tr.value=qword2wide((qword)((double)begin*(double)max));
	MCDoAction(player, mcActionSetSelectionBegin, (void *)&tr);
	tr.value=qword2wide((qword)((double)end*(double)max));
	MCDoAction(player, mcActionSetSelectionDuration, (void *)&tr);
}

static float getTime(MovieController player, Movie movie)
{
	qword max=GetMovieDuration(movie);
	TimeRecord tr;
	GetMovieTime(movie, &tr);
	return (float)((double)wide2qword(tr.value)/(double)max);
}

static void setTime(MovieController player, Movie movie, float value)
{
	qword max=GetMovieDuration(movie);
	TimeRecord tr;
	GetMovieTime(movie, &tr);
	tr.value=qword2wide((qword)((double)value*(double)max));
	MCDoAction(player, mcActionGoToTime, (void *)&tr);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static pascal OSErr DrawCompleteProc(Movie theMovie, long refCon)
{
	GWorldPtr	offWorld = (GWorldPtr)(void *)(DWORD)refCon;
	Rect		bounds;
	Ptr			baseAddr;
	long		rowBytes;
	
	if(LockPixels(GetGWorldPixMap(offWorld)))
	{
		// get the information we need from the GWorld
		GetPixBounds(GetGWorldPixMap(offWorld), &bounds);
		baseAddr = GetPixBaseAddr(GetGWorldPixMap(offWorld));
		rowBytes = QTGetPixMapHandleRowBytes(GetGWorldPixMap(offWorld));

		AquickTime *aqt=getAqt(theMovie);
		if(aqt)
			aqt->frame(baseAddr, rowBytes, bounds);
		UnlockPixels(GetGWorldPixMap(offWorld));
	}
	return noErr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

AquickTime::AquickTime(char *filename)
{
	strcpy(this->filename, filename);
	bitmap=NULL;
	this->playmode=0;
	this->loopstart=0;
	this->looplength=1;
	this->pos=0;
	this->rate=0.f;
	this->sel=false;
	this->play=false;
	this->palindrome=false;
	this->posfocus=false;

	this->theMovie=NULL;
	this->thePlayer=NULL;

	this->state=state2INIT;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

AquickTime::~AquickTime()
{
	close();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void AquickTime::link(MediaBitmap *bmp)
{
	qtHost.section.enter(__FILE__,__LINE__);
	bitmap=bmp;
	if(bmp)
	{
		bmp->lock(__FILE__,__LINE__);
		int s=bmp->getWidth()*bmp->getHeight()*4;
		memset(bmp->getPixels(), 0, s);
		bmp->unlock();
	}
	qtHost.section.leave();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void AquickTime::frame(Ptr bits, int row, Rect r)
{
	if(bitmap&&bits)
	{
		bitmap->lock(__FILE__,__LINE__);
		{
			int ws=r.right-r.left;
			int hs=r.bottom-r.top;
			int wd=bitmap->getWidth();
			int hd=bitmap->getHeight();
			Ptr	dbits=(Ptr)bitmap->getPixels();
			int w=mini(ws, wd);
			int h=mini(hs, hd);
			int x,y;
			int	xs=0;
			int	ys=0;
			int	xd=0;
			int yd=0;
			if(ws<wd)
				xd=(wd-ws)/2;
			else if(ws>wd)
				xs=(ws-wd)/2;
			if(hs<hd)
				yd=(hd-hs)/2;
			else
				ys=(hs-hd)/2;
			for(y=0; y<h; y++)
			{
				dword *src=(dword *)(bits+row*(y+ys))+xs;
				dword *dst=(dword *)(dbits+(y+yd)*wd*4)+xd;
				for(x=0; x<w; x++)
				{
					byte a,r,g,b;
					colorRGBA(&r, &g, &b, &a, *(src++));
					*(dst++)=color32(g, r, a, b);
				}
				//memcpy(dst, src, w*4);
			}
		}
		bitmap->plug_updated=true;
		bitmap->unlock();
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void AquickTime::init(MovieDrawingCompleteUPP myDrawCompleteProc)
{
	GWorldPtr		offWorld;
	Rect			bounds;
    short			actualResId = DoTheRightThing;
    OSErr			result = 0;
	FSSpec			theFSSpec;
    short			resRefNum = -1;

	this->lstart=-1;
	this->llength=-1;
	this->mrate=-1;
	this->mpos=this->pos;
	this->mplay=true;
	this->msel=false;
	this->mpalindrome=false;
	this->sens=1.f;

	this->theMovie=NULL;
	this->thePlayer=NULL;


	result = NativePathNameToFSSpec(filename, &theFSSpec, 0 /* flags */);
	if (result) {dbgprint("NativePathNameToFSSpec failed %d\n", result); goto bail; }
	
    result = OpenMovieFile(&theFSSpec, &resRefNum, 0);
	if (result) {dbgprint("OpenMovieFile failed %d\n", result); goto bail; }
		
	result = NewMovieFromFile(&theMovie, resRefNum, &actualResId, (unsigned char *) 0, 0, (Boolean *) 0);
	if (result) {dbgprint("NewMovieFromFile failed %d\n", result); goto bail; }

	if (resRefNum != -1)
		CloseMovieFile(resRefNum);

	GetMovieBox(theMovie, &bounds);

	result=QTNewGWorld(&offWorld, k32ARGBPixelFormat, &bounds, NULL, NULL, 0);
	if (result) {dbgprint("QTNewGWorld failed %d\n", result); goto bail; }

	SetGWorld(offWorld, NULL);
	thePlayer = NewMovieController(theMovie, &bounds, mcTopLeftMovie | mcNotVisible);
	SetMovieGWorld(theMovie, offWorld, NULL);
	SetMovieActive(theMovie, true);
	SetMovieDrawingCompleteProc(theMovie, movieDrawingCallWhenChanged, myDrawCompleteProc, (long)offWorld); 
	SetMovieAudioContext(theMovie, NULL);

	{
		bool b=true;
		MCDoAction(thePlayer, mcActionSetPlaySelection, (void *)b);
	}
	{
		int r=1<<16;
		MCDoAction(thePlayer, mcActionPlay, (void *)r);
	}

	setLoop(thePlayer, theMovie, 0.f, 1.f);

	state=stateOK;
	return;
bail:
	state=stateERROR;
	close();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void AquickTime::close()
{
    if(thePlayer) 
	{
		MCDoAction(thePlayer, mcActionMovieFinished, NULL);
		DisposeMovieController(thePlayer);
		thePlayer=NULL;
	}

    if (theMovie)
	{
		DisposeMovie(theMovie);
		theMovie=NULL;
	}
	state=stateERROR;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void AquickTime::process()
{
	if(mplay)
	{
		if(sel!=msel)
		{
			msel=sel;
			if(msel)
				setLoop(thePlayer, theMovie, lstart, llength);
			else
				setLoop(thePlayer, theMovie, 0.f, 1.f);
		}
		if(msel&&(lstart!=loopstart)||(llength!=looplength))
		{
			lstart=loopstart;
			llength=looplength;
			setLoop(thePlayer, theMovie, lstart, llength);
		}
		if(posfocus)
		{
			mpos=pos;
			setTime(thePlayer, theMovie, mpos);
		}
		else
		{
			pos=::getTime(thePlayer, theMovie);
			if(mrate!=rate)
			{
				int r=(int)((sens*rate)*65536.f);
				SetMovieRate(theMovie, r);
				mrate=rate;
			}			
		}
		if(mpalindrome!=palindrome)
		{
			sens=1.f;
			mpalindrome=palindrome;
		}

		MCIdle(thePlayer);

		{
			float cstart=msel?lstart:0.f;
			float clength=msel?llength:1.f;

			float	c=::getTime(thePlayer, theMovie);

			if(c<=cstart)
			{
				if(palindrome)
				{
					setTime(thePlayer, theMovie, cstart);
					if(mrate*sens<0.f)
						sens=-sens;
				}
				else
				{
					setTime(thePlayer, theMovie, cstart+clength);
				}
				mrate=0.f;
			}
			else if(c>=cstart+clength)
			{
				if(palindrome)
				{
					setTime(thePlayer, theMovie, cstart+clength);
					if(mrate*sens>0.f)
						sens=-sens;
				}
				else
				{
					setTime(thePlayer, theMovie, cstart);
				}
				mrate=0.f;				
			}
		}

		if(!play)
		{
			mplay=false;
			switch(playmode)
			{
				case 0:
				{
					float cstart=msel?lstart:0.f;
					SetMovieRate(theMovie, 0);
					setTime(thePlayer, theMovie, cstart);
				}
				break;
				case 1:
				SetMovieRate(theMovie, 0);
				break;
				case 2:
				break;
			}
		}
	}
	else
	{
		if(play)
		{
			int r=(int)((sens*rate)*65536.f);
			SetMovieRate(theMovie, r);
			mplay=true;
		}
		if(posfocus)	// seek in pause
			mplay=true;
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

AqtHost::AqtHost()
{
	memset(qt, 0, sizeof(qt));
	brun=true;
	bstop=false;
	myDrawCompleteProc=NULL;
	start();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

AqtHost::~AqtHost()
{
	brun=false;
	while(!bstop)
		sleep(1);
	// all qt not cleaned, but not important as qtHost is a global var and elektronika quit here
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void AqtHost::run()
{
	InitializeQTML(0);
	EnterMovies();
	this->setPriority(Athread::priorityHIGH);

	{
		myDrawCompleteProc = NewMovieDrawingCompleteUPP(DrawCompleteProc);
		int						i;
		int						oneInit=0;

		while(brun)
		{
			section.enter(__FILE__,__LINE__);
			for(i=0; i<MAXQTMOVIE; i++)
			{
				if(qt[i])
				{
					switch(qt[i]->state)
					{
						case AquickTime::state2INIT:
						if(!oneInit)
						{
							qt[i]->init(myDrawCompleteProc);
							oneInit+=12;
						}
						break;
						case AquickTime::stateOK:
						qt[i]->process();
						break;
						case AquickTime::state2REMOVE:
						qt[i]->close();
						delete(qt[i]);
						qt[i]=NULL;
						break;
					}
				}
			}
			section.leave();
			if(oneInit>0)
				oneInit--;
			sleep(10);
		}

		if (myDrawCompleteProc)
		{
			DisposeMovieDrawingCompleteUPP(myDrawCompleteProc);
			myDrawCompleteProc=NULL;
		}
	}

	//ExitMovies();			// hang too !!!!!
	//TerminateQTML();		// hang !! (fucking QT, not important, elektronika will close now)

	bstop=true;
	brun=false;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

AquickTime * AqtHost::newQT(char *filename)
{
	AquickTime *q=new AquickTime(filename);
	bool		test=false;
//	if(myDrawCompleteProc)
//		q->init(myDrawCompleteProc);
	section.enter(__FILE__,__LINE__);
	{
		int i;
		for(i=0; i<MAXQTMOVIE; i++)
		{
			if(!qt[i])
			{
				qt[i]=q;
				test=true;
				break;
			}
		}
	}
	section.leave();
	if(!test)
	{
		delete(q);
		q=NULL;
	}
	return q;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void AqtHost::delQT(AquickTime *q)
{
	section.enter(__FILE__,__LINE__);
	q->state=AquickTime::state2REMOVE;
	section.leave();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

AqtHost		qtHost;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
