/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//	CONTROL.H					(c)	YoY'01						WEB: www.aestesis.org
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifndef							_ACONTROL_H_
#define							_ACONTROL_H_
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include						"elektrodef.h"
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//	If you use directly the variables in the class API, it's at your own risks. Prefer the methods...   

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#define							CTRLTIMEREPAINT					50		// time in millisecond of the check for repaint of GUI controls modified Acontrol
#define							NBINSTANT						10

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#define							guidCONTROL						(Acontrol::CI.guid)

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EDLL char						*notes[];

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

enum
{
								keymodeNOTHING				= 0,
								keymodeSELECT,
								keymodeCYCLE,
								keymodePRESS,
								keymodeSWITCH
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class AcontrolObjMap : public Aobject
{
public:
	ELIBOBJ

	EDLL 						AcontrolObjMap					(char *name, class AcontrolObj *ctrlobj);
	EDLL virtual				~AcontrolObjMap					();

	EDLL virtual void			paint							(Abitmap *b);
	EDLL virtual bool			mouse							(int x, int y, int state, int event);
	EDLL virtual void			pulse							();

	class AcontrolObj			*ctrlobj;
	bool						selected;
	int							npulse;
};


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class AcontrolObj : public Aobject
{
public:
	ELIBOBJ 

	EDLL						AcontrolObj						(char *name, Aobject *father, int x, int y, int w, int h);


	virtual bool				implementOsc					() { return false; }	// return true if overide Acontrol::oscMessage
	virtual bool				oscMessage						(class AoscMessage *reply, class AoscMessage *query, int action) { return false; } // return true if reply used

	virtual bool				sequence						(int nctrl, float value)=0;								
	void						controlPaint					(Abitmap *b, int w, int h) { }
	EDLL virtual void			update							(Abitmap *b);

	EDLL void					selectMap						(AcontrolObjMap *map);
	EDLL void					showMap							(bool show);

	EDLL virtual bool			size							(int w, int h);
	
	bool						fromSequencer;
	class Acontrol				*control;
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class Amidimap
{
public:

	enum
	{
								modeABS=1,
								modeREL1,
								modeREL2,
								modeREL3,
								modeABS_14,
								modeREL1_14,
								modeREL2_14,
								modeREL3_14
	};

	int							status;
	int							channel;
	int							data;
	float						minCtrl;
	float						maxCtrl;
	int							modeCtrl;
	char						name[32];
	dword						color;

								Amidimap();
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

__inline Amidimap::Amidimap()
{
	status=-1;
	name[0]=0;
	color=0xff000000;
	minCtrl=0.f;
	maxCtrl=1.f;
	modeCtrl=modeABS;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#define							CTRLMAXKEY						16
#define							CTRLMAXCONTROLER				10

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class Akeymap
{
public:
	int							kmode;
	int							key[CTRLMAXKEY];

								Akeymap();
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

__inline Akeymap::Akeymap()
{
	kmode=keymodeNOTHING;
	memset(key, 0, sizeof(key));
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//!  a class that manage midi/keyboard shortcuts and recording sequence.
class Acontrol : public Anode
{
public:

//! enum controller type
enum
{
	NOTHING=0,
	CONTROLER_01=1,
	CONTROLER_02,
	CONTROLER_03,
	CONTROLER_04,
	CONTROLER_05,
	CONTROLER_06,
	CONTROLER_07,
	CONTROLER_08,
	CONTROLER_09,
	CONTROLER_10,
	KEY=100,
	KEY_01=KEY,
	KEY_02,
	KEY_03,
	KEY_04,
	KEY_05,
	KEY_06,
	KEY_07,
	KEY_08,
	KEY_09,
	KEY_10,
	KEY_11,
	KEY_12,
	KEY_13,
	KEY_14,
	KEY_15,
	KEY_16,
	KEY_17,
	KEY_18,
	KEY_19,
	KEY_20
};

enum
{
	oscNOTDEFINED=0,
	oscPRESS,
	osc2STATES
};

	ELIBOBJ

	EDLL						Acontrol						(QIID qiid, char *name, class Atable *table, class AcontrolObj *o, int type=NOTHING);
	EDLL						Acontrol						(QIID qiid, char *name, class Aeffect *ef, class AcontrolObj *o, int type=NOTHING);
	EDLL virtual				~Acontrol						();

	EDLL bool					save							(Afile *f);
	EDLL bool					load							(Afile *f);
	
	EDLL bool					saveValues						(Afile *f);
	EDLL bool					loadValues						(Afile *f);

	EDLL virtual void			setInfo							(int nctrl, char *name, dword color);

	EDLL void					selectMap						(AcontrolObjMap *map);
	EDLL bool					isMapped						();

	EDLL virtual bool			set								(int nctrl, float value);
	EDLL virtual float			get								(int nctrl);
	EDLL virtual bool			sequence						(int nctrl,	float value);
	EDLL virtual bool			midiseq							(int nctrl, int status, int midi0, int midi1);
	EDLL virtual bool			keyseq							(int nctrl, int kmode, int nkey, int event);
	EDLL virtual void			set2memValue					();
	EDLL virtual void			select							();
	
	EDLL virtual void			randomize						();
	
	EDLL virtual void			midiSend						(int ctrl, float value);

	EDLL virtual bool			oscMessage						(class AoscMessage *reply, class AoscMessage *query, int action);	// return true if reply used

	EDLL static float			midiCtrl2Value					(float value, int mode, int msb, int lsb, float minRange, float maxRange);

	
	QIID						qiid;
	class Aeffect				*effect;
	class Atable				*table;
	class AcontrolObj			*object;						
	int							type;
	int							oscType;

	Amidimap					midimap[CTRLMAXCONTROLER];
	Asection					smidimap;
	Akeymap						keymap[CTRLMAXCONTROLER];

	float						memValue[CTRLMAXCONTROLER];
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class AmidiInfo
{
public:
	int							channel;
	int							status;
	int							data0;
	int							data1;
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//! a class that display the midi/keyboard shortcuts properties (elektronika internal)
class Amapping : public Aobject
{
public:
	ELIBOBJ

	EDLL						Amapping						(char *name, Aobject *father, int x, int y, int w, int h);
	EDLL virtual				~Amapping						();

	EDLL void					setControl						(Acontrol *c);
	EDLL void					setTable						(Atable *table);

	EDLL virtual void			paint							(Abitmap *b);
	EDLL virtual bool			notify							(Anode *o, int event, dword p=0);
	EDLL virtual bool			mouse							(int x, int y, int state, int event);
	EDLL virtual void			pulse							();

	EDLL virtual bool			midiMapping						(int channel, int status, int p0, int p1, dword time);

	bool						isUsed							() { return (state&stateVISIBLE)?true:false; }

	EDLL void					midiSet							();
	EDLL void					midiControlGet					();
	EDLL void					midiControlSet					();

	EDLL void					keyGet							();
	EDLL void					keySet							();
	EDLL void					keySetSet						();

	EDLL void					del								(Acontrol *c);
	EDLL void					del								(Aeffect *e);

	Atable						*table;
	Acontrol					*control;

	Afont						*font;

	AmidiInfo					minstant[NBINSTANT];
	Asection					sinstant;
	bool						active;
	int							fstatus;
	int							fchannel;
	Abutton						*bactive;
	Alist						*fltType;
	Aitem						*itemType;
	Alist						*fltChannel;
	Aitem						*itemChannel;
	Abutton						*binstant[NBINSTANT];

	Astatic						*ctrlName;
	Alist						*controls;
	Aitem						*itemControls;
	Alist						*types;
	Aitem						*itemTypes;
	Alist						*channels;
	Aitem						*itemChannels;
	Alist						*notes;
	Aitem						*itemNotes;
	Alist						*numctrl;
	Aitem						*itemNumctrl;
	Alist						*minRange;
	Alist						*maxRange;
	Aitem						*iminRange;
	Aitem						*imaxRange;
	Alist						*modectrl;
	Aitem						*imodectrl;
	Astatic						*ctrlValue;

	class Aselkey				*key[CTRLMAXKEY];
	Alist						*keykey;
	Aitem						*ikeykey;
	Alist						*keyctrl;
	Aitem						*ikeyctrl;

	bool						refreshInstant;
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EDLL void						controlPaint					(Abitmap *b, int w, int h);

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#endif							//_ACONTROL_H_
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
