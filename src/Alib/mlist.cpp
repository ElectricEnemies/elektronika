/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include						"export.h"
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//	MLIST.CPP					(c)	YoY'05						WEB: www.aestesis.org
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include						<stdio.h>
#include						"mlist.h"
#include						"interface.h"
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

ADLL ACI						Amlist::CI=ACI("Alist", GUID(0xAE57E515,0x00001160), &Aobject::CI, 0, NULL);

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

ADLL Amlist::Amlist(char *name, Aobject *L, int x, int y, int w, int h, Aitem *items) : Aobject(name, L, x, y, w, h)
{
	font=alib.getFont(fontTERMINAL06);
	this->items=items;
	colorBACK=0x80404000;
	colorFORE=0x80ffffff;
	colorBACKSEL=0xff808000;
	colorSEL=0xff000000;
	colorBORDER=0x80ffffff;
	yy=0;
	{
		Aitem *i=(Aitem *)items->fchild;
		while(i)
		{
			if(i->state&Aitem::stateSELECTED)
				break;
			i=(Aitem *)i->next;
			yy-=16.f;
		}
	}
	yy=mini(0.f, maxi(yy, (float)(pos.h-items->count()*16)));
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

ADLL Amlist::~Amlist()
{
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

ADLL void Amlist::paint(Abitmap *b)
{
	b->boxfa(0, 0, pos.w, pos.h, colorBACK);

	{
		Aitem	*i=(Aitem *)items->fchild;
		int		y=(int)yy;

		while(i)
		{
			bool	t=(i->state&Aitem::stateSELECTED)?true:false;
			if(t)
				b->boxfa(0, y+1, pos.w, y+14, colorBACKSEL);
			font->set(b, 4, y+4, i->name, t?colorSEL:colorFORE);
			y+=16;
			i=(Aitem *)i->next;
		}
	}

	b->boxa(0, 0, pos.w-1, pos.h-1, colorBORDER);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

ADLL bool Amlist::mouse(int x, int y, int state, int event)
{
	switch(event)
	{
		case mouseLDOWN:
		{
			Aitem	*i=(Aitem *)items->fchild;
			int		ny=(int)yy;
			while(i)
			{
				if((y>=ny)&&(y<(ny+15)))
				{
					if(i->state&Aitem::stateSELECTED)
						i->state&=~Aitem::stateSELECTED;
					else
						i->state|=Aitem::stateSELECTED;
					father->notify(this, nyCHANGE, (dword)i);
					repaint();
					break;
				}
				ny+=16;
				i=(Aitem *)i->next;
			}
		}
		return TRUE;

		case mouseLUP:
		return TRUE;

		case mouseWHEEL:
		{
			float	dy=(float)getWindow()->mouseW/8.f;
			yy+=dy;
			yy=mini(0.f, maxi(yy, (float)(pos.h-items->count()*16)));
		}
		return true;

	}
	return FALSE;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
