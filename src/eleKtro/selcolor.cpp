/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include						"elektroexp.h"
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//	SELCOLOR.CPP				(c)	YoY'01						WEB: www.aestesis.org
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include						<windows.h>
#include						<stdio.h>
#include						<math.h>
#include						<assert.h>

#include						"selcolor.h"
#include						"interface.h"
#include						"../alib/resource.h"
#include						"effect.h"
#include						"resource.h"
#include						"tcpRemote.h"
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EDLL ACI						Aselcolor::CI=ACI("Aselcolor", GUID(0xE4EC7600,0x00010070), &AcontrolObj::CI, 0, NULL);

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class Awpal : public Aobject
{
public:
	ELIBOBJ

								Awpal							(char *name, Aobject *L, int x, int y, int w, int h);

	virtual void				paint							(Abitmap *b);
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EDLL ACI						Awpal::CI=ACI("Awpal", GUID(0xE4EC7600,0x00010071), &Aobject::CI, 0, NULL);

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Awpal::Awpal(char *name, Aobject *L, int x, int y, int w, int h) : Aobject(name, L, x, y, w, h)
{
	zorder(zorderTOP);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Awpal::paint(Abitmap *bit)
{
	int		x,y;
	double	aa=0.0;
	double	da=(3.0*PI/2.0)/pos.w;
	int		mh=pos.h>>1;
	for(x=0; x<pos.w; x++)
	{
		double	ar=aa;
		double	ag=aa+PI/2.0;
		double	ab=aa+PI;
		if(ar>3.0*PI/2.0)
			ar-=3.0*PI/2.0;
		if(ag>3.0*PI/2.0)
			ag-=3.0*PI/2.0;
		if(ab>3.0*PI/2.0)
			ab-=3.0*PI/2.0;
		double	r=maxi(sin(ar)*255.99, 0.0);
		double	g=maxi(sin(ag)*255.99, 0.0);
		double	b=maxi(sin(ab)*255.99, 0.0);
		for(y=0; y<mh; y++)
		{
			double	a1=(double)y/(double)mh;
			double	a0=(1.0-a1)*255.99;
			bit->pixel(x, y, color32((int)(r*a1+a0), (int)(g*a1+a0), (int)(b*a1+a0)));
		}
		for(y=mh; y<pos.h; y++)
		{
			double	a1=(double)(y-mh)/(double)mh;
			double	a0=(1.0-a1);
			bit->pixel(x, y, color32((int)(r*a0), (int)(g*a0), (int)(b*a0)));
		}
		aa+=da;
	}
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EDLL Aselcolor::Aselcolor(QIID qiid, char *name, Aobject *L, int x, int y, int w, int h) : AcontrolObj(name, L, x, y, w, h)
{
	control=new Acontrol(qiid, name, Aeffect::getEffect(L), this, Acontrol::CONTROLER_03);
	control->setInfo(Acontrol::CONTROLER_01, "blue", 0xff000080);
	control->setInfo(Acontrol::CONTROLER_02, "green", 0xff008000);
	control->setInfo(Acontrol::CONTROLER_03, "red", 0xff800000);
	border=0xff5A5956;
	color=0x01010101;
	set(0xff000000);
	test=0;
	wpal=null;
	defcolor=0xff000000;
	isdef=false;
	timer(CTRLTIMEREPAINT);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EDLL Aselcolor::~Aselcolor()
{
	delete(control);
	if(wpal)
		delete(wpal);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EDLL bool Aselcolor::mouse(int x, int y, int state, int event)
{
	switch(event)
	{
		case mouseLDBLCLK:
		cursor(cursorINK);
		mouseCapture(true);
		test=3;
		{
			Awindow	*w=getWindow();
			wpal=new Awpal("wpal", w, 0, w->pos.h-30, w->pos.w, 30);
			wpal->setTooltips("color palette");
			wpal->show(true);
			wpal->repaint();
		}
		break;

		case mouseLDOWN:
		control->select();
		if(!test)
		{
			byte	r,g,b;
			colorRGB(&r, &g, &b, color);
			rgb2hls(&h, &l, &s, r, g, b);
			xx=x;
			yy=y;
			test=(state&mouseCTRL)?2:1;
			cursor(cursorHANDSEL);
			mouseCapture(true);
		}
		else if(test==3)
			test=4;
		return TRUE;

		case mouseLUP:
		if(test==3)
			return TRUE;
		if(test==4)
		{
			HDC			hdc=GetDC(NULL);
			int			xx,yy;
			COLORREF	cr;
			Awindow		*w=getWindow();
			w->getPosition(this, &xx, &yy);
			cr=GetPixel(hdc, x+xx+w->pos.x, y+yy+w->pos.y);
			set(color32((byte)(cr&0x0ff), (byte)((cr>>8)&0x0ff), (byte)((cr>>16)&0x0ff)));
			ReleaseDC(NULL, hdc);
			repaint();
		}
		mouseCapture(false);
		test=0;
		father->notify(this, nyCHANGE, color);

//				control->set(Acontrol::CONTROLER_01, (int)(xx*127.99f));
		if(wpal)
		{
			wpal->destroy();
			wpal=null;
		}
		return TRUE;

		case mouseNORMAL:
		if(!test)
		{
			focus(this);
			if(getKeyboardState()&keyboardLALT)
			{
				set(defcolor);
				father->notify(this, nyCHANGE);
				return true;
			}
		}
		else if((test==1)||(test==2))
		{
			float	dx=(x-xx)*alib.mouseSensibility;
			float	dy=(y-yy)*alib.mouseSensibility;
			byte	r,g,b;
			float	h0,l0,s0;
			switch(test)
			{
				case 1:
				h0=h+dx*60.f;
				l0=maxi(mini(l-dy, 1.f), 0.f);
				s0=s;
				while(h0<0.f)
					h0+=360.f;
				while(h0>=360.f)
					h0-=360.f;
				break;

				case 2:
				h0=h;
				l0=l;
				s0=maxi(mini(s-dy, 1.f), 0.f);
				break;
			}
			hls2rgb(h0, l0, s0, &r, &g, &b);
			set(color32(r, g, b));
			father->notify(this, nyCHANGE, color);
			repaint();
			if(((state&mouseCTRL)&&(test==1))||((!(state&mouseCTRL))&&(test==2)))
			{
				test=(state&mouseCTRL)?2:1;
				h=h0;
				l=l0;
				s=s0;
				xx=x;
				yy=y;
			}
		}
		if(test<3)
			cursor(cursorHANDSEL);
		else
			cursor(cursorINK);
		return TRUE;

	}
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EDLL void Aselcolor::set(dword color)
{
	if(!isdef)
	{
		defcolor=color;
		isdef=true;
	}
	if((this->color&0xff)!=(color&0xff))
		control->set(Acontrol::CONTROLER_01, (float)(color&0xff)/255.f);
	if((this->color&0xff00)!=(color&0xff00))
		control->set(Acontrol::CONTROLER_02, (float)((color&0xff00)>>8)/255.f);
	if((this->color&0xff0000)!=(color&0xff0000))
		control->set(Acontrol::CONTROLER_03, (float)((color&0xff0000)>>16)/255.f);
	this->color=color;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EDLL dword Aselcolor::get()
{
	return color;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EDLL bool Aselcolor::sequence(int nctrl, float value)
{
	switch(nctrl)
	{
		case Acontrol::CONTROLER_01:
		color=(color&0xffffff00)|((int)(value*255.f));
		break;

		case Acontrol::CONTROLER_02:
		color=(color&0xffff00ff)|((int)(value*255.f)<<8);
		break;

		case Acontrol::CONTROLER_03:
		color=(color&0xff00ffff)|((int)(value*255.f)<<16);
		break;

		default:
		assert(FALSE);
		break;
	}
	ctrlPaint=true;
	father->notify(this, nyCHANGE, color);
	return true;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EDLL bool Aselcolor::keyboard(int event, int ascii, int scan, int state)
{
	switch(event)
	{
		case keyboardDOWN:
		if(state&keyboardALT)
		{
			set(defcolor);
			father->notify(this, nyCHANGE);
			return true;
		}
		break;
	}
	return false;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EDLL void Aselcolor::pulse()
{
	if(colorf!=color)
	{
		colorf=color;
		repaint();
	}	
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EDLL void Aselcolor::paint(Abitmap *b)
{
	b->box(0, 0, pos.w-1, pos.h-1, border);
	b->box(1, 1, pos.w-2, pos.h-2, border);
	b->boxf(2, 2, pos.w-3, pos.h-3, color);
	controlPaint(b, pos.w, pos.h);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EDLL bool Aselcolor::oscMessage(AoscMessage *reply, AoscMessage *query, int action)
{
	switch(action)
	{
		case oscDOCUMENTATION:
		if(tooltips)
			reply->add(new AoscString(tooltips));
		else if(name)
			reply->add(new AoscString(name));
		else
			reply->add(new AoscString(""));
		return true;

		case oscTYPESIGNATURE:
		reply->add(new AoscString(",r"));
		return true;

		case oscSETVALUE:
		if(query->fchild&&query->fchild->isCI(&AoscColor::CI))
		{
			dword cf=color;
			dword c=((AoscColor *)query->fchild)->value;
			set(c);
			if((cf&0x00FFFFFF)!=(c&0x00FFFFFF))
				father->notify(this, nyCHANGE, color);
		}		
		return false;

		case oscGETVALUE:
		reply->add(new AoscColor(color));
		return true;
	}
	return false;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
