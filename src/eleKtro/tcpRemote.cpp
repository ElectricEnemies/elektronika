/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include						"elektroexp.h"
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//	TCPREMOTE.CPP				(c)	YoY'04						WEB: www.aestesis.org
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//#include						<windows.h>
//#include						<process.h>
//#include						<iostream.h>
//#include						<fstream.h>
#include						<stdio.h>
#include						<assert.h>
//#include						<winsock2.h>
#include						"tcpRemote.h"
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EDLL ACI						AtcpRemote::CI			= ACI("AtcpRemote",			GUID(0xE4EC7600,0x00000200), &Anode::CI, 0, NULL);
EDLL ACI						AoscStream::CI			= ACI("AoscStream",			GUID(0xE4EC7600,0x00000210), &Anode::CI, 0, NULL);
EDLL ACI						AoscMessage::CI			= ACI("AoscMessage",		GUID(0xE4EC7600,0x00000220), &Anode::CI, 0, NULL);

EDLL ACI						AoscData::CI			= ACI("AoscData",			GUID(0xE4EC7600,0x00000230), &Anode::CI, 0, NULL);
EDLL ACI						AoscInteger::CI			= ACI("AoscInteger",		GUID(0xE4EC7600,0x00000231), &AoscData::CI, 0, NULL);
EDLL ACI						AoscFloat::CI			= ACI("AoscFloat",			GUID(0xE4EC7600,0x00000232), &AoscData::CI, 0, NULL);
EDLL ACI						AoscString::CI			= ACI("AoscString",			GUID(0xE4EC7600,0x00000233), &AoscData::CI, 0, NULL);
EDLL ACI						AoscColor::CI			= ACI("AoscColor",			GUID(0xE4EC7600,0x00000234), &AoscData::CI, 0, NULL);
EDLL ACI						AoscBitmap::CI			= ACI("AoscBitmap",			GUID(0xE4EC7600,0x00000235), &AoscData::CI, 0, NULL);

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

__inline int padding(int n)
{
	return ((n&3)>0)?((n&~3)+4):(n);
}

int readInt(byte *data)
{
	return (int)((data[0]<<24)|(data[1]<<16)|(data[2]<<8)|(data[3]));
}

int readInt(int *ri, byte *data, int max)
{
	if(max>=4)
	{
		*ri=readInt(data);
		return 4;
	}
	return 0;
}

int readFloat(float *rf, byte *data, int max)
{
	if(max>=4)
	{
		int	i=readInt(data);
		memcpy(rf, &i, 4);	// bit copy float data stocked in an int
		return 4;
	}
	return 0;
}

int readString(char *str, byte *data, int max)
{
	max=mini(max, MAXOSCSTRING);
	byte	*s=data;
	byte	*d=(byte *)str;
	int		n=0;
	while(*s&&n<max)
	{
		*(d++)=*(s++);
		n++;
	}
	if(*s)
		return -1;
	*d=0;
	return padding(n+1);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int writeInt(int i, byte *data, int sizemax)
{
	if(sizemax>=4)
	{
		byte	*src=(byte *)&i;
		data[0]=src[3];
		data[1]=src[2];
		data[2]=src[1];
		data[3]=src[0];
		return 4;
	}
	return 0;
}

int writeFloat(float f, byte *data, int sizemax)
{
	int	i;
	memcpy(&i, &f, 4);
	return writeInt(i, data, sizemax);
}

int writeString(char *str, byte *data, int sizemax)
{
	byte	*s=(byte *)str;
	byte	*d=data;
	int		n=0;
	while(*s&&(n<sizemax))
	{
		*(d++)=*(s++);
		n++;
	}
	*(d++)=0;
	n++;
	while((n&3)&&(n<sizemax))
	{
		*(d++)=0;
		n++;
	}
	return n;
}

int writeBitmap(Abitmap *bitmap, byte *data, int sizemax)
{
	int		n=0;
	Abuffer	*f=new Abuffer("bitmap", 65536*2);

	bitmap->save(f, bitmapJPG, 90);
	int s=(int)f->size;

	if((s+4)<sizemax)
	{
		n+=writeInt(s, data, sizemax);
		memcpy(data+4, f->buffer, s);
		n+=s;
	}
	else
	{
		n+=writeInt(0, data, sizemax);
	}
	delete(f);

	while((n&3)&&(n<sizemax))
	{
		data[n]=0;
		n++;
	}
	return n;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static SOCKET init(int port)
{
	WSADATA wd;
	if(WSAStartup(MAKEWORD(2, 2), &wd)==0)
	{
		SOCKET		s;
		s=socket(AF_INET, SOCK_STREAM, 0);
		if(s!=INVALID_SOCKET)
		{
			SOCKADDR_IN si;
			si.sin_family=AF_INET;
			si.sin_port=htons(port);
			si.sin_addr.s_addr=htonl(INADDR_ANY);
			if(bind(s,(struct sockaddr *) &si,sizeof(SOCKADDR_IN))!=SOCKET_ERROR)
				return s;
		}
	}
	return INVALID_SOCKET;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EDLL AtcpRemote::AtcpRemote(Atable *t) : Athread()
{
	memset(oscStream, 0, sizeof(oscStream));
	table=t;
	socket=INVALID_SOCKET;
	srvstop=false;
	srvrun=false;
	start();
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EDLL AtcpRemote::~AtcpRemote()
{
	srvstop=true;
	if(socket!=INVALID_SOCKET)
	{
		closesocket(socket);
		socket=INVALID_SOCKET;
	}
	while(srvrun)
		sleep(1);

	section.enter(__FILE__,__LINE__);
	{
		int	i;
		for(i=0; i<MAXOSCSTREAM; i++)
		{
			if(oscStream[i])
				oscStream[i]->close();	// warning: close call delete in run thread
		}
	}
	section.leave();

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EDLL void AtcpRemote::run()
{
	socket=init(5027);
	srvstop=false;
	srvrun=false;
	if(socket!=INVALID_SOCKET)
	{
		int		ciplen=sizeof(SOCKADDR_IN);
		if(listen(socket,SOMAXCONN)!=SOCKET_ERROR)
		{
			srvrun=true;
			while(!srvstop)
			{
				SOCKADDR_IN	cip;
				SOCKET		csock=accept(socket,(struct sockaddr *)&cip, &ciplen);
				if(csock!=INVALID_SOCKET)
					addStream(csock);
				sleep(1);
			}
		}
		closesocket(socket);
		socket=INVALID_SOCKET;
	}
	WSACleanup();
	srvrun=false;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EDLL void AtcpRemote::delStream(AoscStream *osc)
{
	section.enter(__FILE__,__LINE__);
	{
		int	i;
		for(i=0; i<MAXOSCSTREAM; i++)
		{
			if(oscStream[i]==osc)
			{
				oscStream[i]=null;
				break;
			}
		}
		assert(i!=MAXOSCSTREAM);	// error, not found
	}
	section.leave();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EDLL void AtcpRemote::addStream(SOCKET s)
{
	bool		ok=false;

	section.enter(__FILE__,__LINE__);
	{
		AoscStream	*osc=new AoscStream(this, s);
		int	i;
		for(i=0; i<MAXOSCSTREAM; i++)
		{
			if(oscStream[i]==null)
			{
				oscStream[i]=osc;
				ok=true;
				break;
			}
		}
		if(ok)
			osc->start();
		else
		{
			delete(osc);
			closesocket(s);
		}
	}
	section.leave();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EDLL void AtcpRemote::idlePulse()
{
	section.enter(__FILE__,__LINE__);
	{
		int	i;
		for(i=0; i<MAXOSCSTREAM; i++)
		{
			if(oscStream[i])
				oscStream[i]->idleProcess(table);
		}
	}
	section.leave();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EDLL AoscStream::AoscStream(AtcpRemote *tcpRemote, SOCKET s) : Anode("osc stream")
{
	memset(rcvmsg, 0, sizeof(rcvmsg));
	memset(sndmsg, 0, sizeof(sndmsg));
	nrcvmsg=0;
	nsndmsg=0;
	nerror=0;
	this->tcpRemote=tcpRemote;
	buffer=new Abuffer("osc buffer", 65536*4);
	socket=s;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EDLL AoscStream::~AoscStream()
{
	if(socket)
	{
		closesocket(socket);
		socket=INVALID_SOCKET;
	}
	section.enter(__FILE__,__LINE__);
	delete(buffer);
	{
		int i;
		for(i=0; i<nrcvmsg; i++)
		{
			delete(rcvmsg[i]);
			rcvmsg[i]=null;
		}
		nrcvmsg=0;
		for(i=0; i<nsndmsg; i++)
		{
			delete(sndmsg[i]);
			sndmsg[i]=null;
		}
		nsndmsg=0;
	}
	section.leave();
	tcpRemote->delStream(this);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EDLL void AoscStream::close()
{
	srvstop=true;
	if(socket)
	{
		closesocket(socket);
		socket=INVALID_SOCKET;
	}
	while(!srvstopped)
		sleep(1);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EDLL void AoscStream::run()
{
	WSADATA		wd;
	int			size;
	byte		buf[65536*2];

	srvstop=false;	
	srvstopped=false;

	if(WSAStartup(MAKEWORD(2, 2), &wd)==0)
	{
		while(!srvstop)
		{
			{
				u_long argp=1;
				ioctlsocket(socket, FIONBIO, &argp);	// non blocking
			}

			while(1)
			{
				size=recv(socket, (char *)buf, sizeof(buf)-1, 0);
				if(size>0)
				{
					section.enter(__FILE__,__LINE__);
					buffer->write(buf, size);
					section.leave();
				}
				else 
					break;
			}

			if(size==SOCKET_ERROR)
			{
				int error=WSAGetLastError();
				if(error!=WSAEWOULDBLOCK)
					break;
			}

			{
				u_long argp=0;
				ioctlsocket(socket, FIONBIO, &argp);	// blocking
			}

			section.enter(__FILE__,__LINE__);
			{
				int i;
				for(i=0; i<nsndmsg; i++)
				{
					AoscMessage *msg=sndmsg[i];
					size=msg->getBytes(buf, sizeof(buf));
					{
						byte datasize[4];
						writeInt(size, datasize, sizeof(datasize));
						if(send(socket, (char *)datasize, sizeof(datasize), 0)!=sizeof(datasize))
							nerror++;
					}
					if(send(socket, (char *)buf, size, 0)!=size)
						nerror++;
					delete(msg);
					sndmsg[i]=null;
				}
				nsndmsg=0;
			}
			section.leave();

			Athread::sleep(1);
		}
	}

	if(socket)
	{
		closesocket(socket);
		socket=INVALID_SOCKET;
	}

	srvstopped=true;
	delete(this);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EDLL void AoscStream::idleProcess(Atable *table)
{
	section.enter(__FILE__,__LINE__);
	while(1)
	{
		int a=(int)buffer->getSize();
		if(a>=4)
		{
			byte ds[4];
			buffer->peek(ds, sizeof(ds));
			int size=readInt(ds);
			if(a>=size+4)
			{
				byte data[65536];
				buffer->read(data, size+4);
				if(nrcvmsg<MAXOSCMESSAGE)
				{
					AoscMessage *msg=new AoscMessage(data+4, size);
					assert(msg!=null);
					if(msg->isOK())
						rcvmsg[nrcvmsg++]=msg;

					else
						nerror++;
				}
			}
			else 
				break;
		}
		else
			break;
	}
	section.leave();
	{
		int i;
		for(i=0; i<nrcvmsg; i++)
			table->oscMessage(this, rcvmsg[i]);
		nrcvmsg=0;
	}
	if(nerror)
		close();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EDLL void AoscStream::reply(AoscMessage *msg)
{
	section.enter(__FILE__,__LINE__);
	if(nsndmsg<MAXOSCMESSAGE)
		sndmsg[nsndmsg++]=msg;
	section.leave();
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EDLL AoscMessage::AoscMessage()
{
	memset(pattern, 0, sizeof(pattern));
	memset(format, 0, sizeof(format));
	bok=true;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EDLL AoscMessage::AoscMessage(byte *data, int size)
{
	bok=true;
	memset(pattern, 0, sizeof(pattern));
	memset(format, 0, sizeof(format));
	{
		int	pos=0;
		int sz;

		sz=readString(pattern, data+pos, size-pos);
		if(sz<0)
		{
			bok=false;
			return;
		}
		pos+=sz;

		sz=readString(format, data+pos, size-pos);
		if(sz<0)
		{
			bok=false;
			return;
		}
		pos+=sz;

		{
			char	*s=format;
			while(*s&&bok)
			{
				switch(*s)
				{
					case 'i':
					{
						int i;
						if(readInt(&i, data+pos, size-pos)==4)
							this->add(new AoscInteger(i));
						else
							bok=false;
					}
					break;
					case 'f':
					{
						float f;
						if(readFloat(&f, data+pos, size-pos)==4)
							this->add(new AoscFloat(f));
						else
							bok=false;
					}
					break;
					case 's':
					{
						char	str[1024];
						if(readString(str, data+pos, size-pos)>=0)
							this->add(new AoscString(str));
						else
							bok=false;
					}
					break;
					case 'r':
					{
						int i;
						if(readInt(&i, data+pos, size-pos)==4)
							this->add(new AoscColor((dword)i));
						else
							bok=false;
					}
					break;
					case ',':
					break;
					default:
					assert(false);	// unknown
					break;
				}
				s++;
			}
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EDLL AoscMessage::~AoscMessage()
{

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EDLL int AoscMessage::getBytes(byte *data, int sizemax)
{
	int size=0;
	memset(data, 0, sizemax);
	size+=writeString(pattern, data, sizemax);
	format[0]=',';
	{
		Anode	*n=lchild;
		char	*f=&format[1];
		while(n)
		{
			if(n->isCI(&AoscString::CI))
				*(f++)='s';
			else if(n->isCI(&AoscInteger::CI))
				*(f++)='i';
			else if(n->isCI(&AoscFloat::CI))
				*(f++)='f';
			else if(n->isCI(&AoscColor::CI))
				*(f++)='r';
			else if(n->isCI(&AoscBitmap::CI))
				*(f++)='j';
			n=n->prev;
		}
		*f=0;
	}
	size+=writeString(format, data+size, sizemax-size);
	{
		Anode	*n=lchild;
		while(n)
		{
			if(n->isCI(&AoscString::CI))
				size+=writeString(((AoscString *)n)->value, data+size, sizemax-size);
			else if(n->isCI(&AoscInteger::CI))
				size+=writeInt(((AoscInteger *)n)->value, data+size, sizemax-size);
			else if(n->isCI(&AoscFloat::CI))
				size+=writeFloat(((AoscFloat *)n)->value, data+size, sizemax-size);
			else if(n->isCI(&AoscColor::CI))
				size+=writeInt(((AoscColor *)n)->value, data+size, sizemax-size);
			else if(n->isCI(&AoscBitmap::CI))
				size+=writeBitmap(((AoscBitmap *)n)->value, data+size, sizemax-size);
			n=n->prev;
		}
	}
	return size;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

AoscInteger::AoscInteger(int i)
{
	value=i;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

AoscFloat::AoscFloat(float f)
{
	value=f;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

AoscBitmap::AoscBitmap(Abitmap *b)
{
	value=b;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

AoscBitmap::~AoscBitmap()
{
	delete(value);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

AoscString::AoscString(char *s)
{
	strcpy(value, s);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

AoscColor::AoscColor(dword c)
{
	value=c;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EDLL char *oscSTRING[]={ "", "\\type-signature", "\\current-value", "\\minimum-value", "\\maximum-value", "\\documentation", "\\ui-signature" };

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
