/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//	DISPATCH.CPP				(c)	YoY'02						WEB: www.aestesis.org
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include						<windows.h>
#include						<math.h>
#include						"dispatch.h"
#include						"resource.h"
#include						"tcpRemote.h"

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

ACI								AdispatchInfo::CI	= ACI("AdispatchInfo",	GUID(0x11111112,0x00000200), &AeffectInfo::CI, 0, NULL);
ACI								Adispatch::CI		= ACI("Adispatch",		GUID(0x11111112,0x00000201), &Aeffect::CI, 0, NULL);
ACI								AdispatchFront::CI	= ACI("AdispatchFront",	GUID(0x11111112,0x00000202), &AeffectFront::CI, 0, NULL);
ACI								AdispatchBack::CI	= ACI("AdispatchBack",	GUID(0x11111112,0x00000203), &AeffectBack::CI, 0, NULL);

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class Awdispatch : public Awindow
{
public:
	AOBJ

								Awdispatch						(char *name, int x, int y, int w, int h, Adispatch *disp);

	virtual bool				mouse							(int x, int y, int state, int event);
	void						pulse							();

	virtual bool				keyboard						(int event, int ascii, int scan, int state);

	int							bac,lx,ly,wx,wy;
	Adispatch					*disp;
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

ACI								Awdispatch::CI		= ACI("Awdispatch",		GUID(0x11111112,0x00000205), &Awindow::CI, 0, NULL);

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Awdispatch::Awdispatch(char *name, int x, int y, int w, int h, Adispatch *disp) : Awindow(name, x, y, w, h)
{
	bac=0;
	this->disp=disp;
	timer(100);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void random(Abitmap *b, int x0, int y0, int x1, int y1)
{
	int	x,y;
	for(y=y0; y<=y1; y++)
	{
		for(x=x0; x<=x1; x++)
		{
			byte	v=rand()&255;
			b->pixel(x, y, color32(v, v, v));
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool Awdispatch::keyboard(int event, int ascii, int scan, int state)
{
	safeGUI.enter(__FILE__,__LINE__);
	bool b=disp->front->getWindow()->keyboard(event, ascii, scan, state);
	safeGUI.leave();
	return b;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool Awdispatch::mouse(int x, int y, int state, int event)
{
	switch(event)
	{
		case mouseLDOWN:
		{
			int max=((pos.w*pos.w+pos.h*pos.h)*7)>>3;
			int	n=x*x+y*y;
			if(n>max)
			{
				wx=pos.x;
				wy=pos.y;
				lx=pos.x+x;
				ly=pos.y+y;
				bac=2;
			}
			else
			{
				wx=pos.x;
				wy=pos.y;
				lx=pos.x+x;
				ly=pos.y+y;
				bac=1;
				cursor(cursorSIZEALL);
			}
			mouseCapture(TRUE);
		}
		return TRUE;

		case mouseNORMAL:
		if(state&mouseL)
		{
			switch(bac)
			{
				case 1:
				move(wx+(x+pos.x)-lx, wy+(y+pos.y)-ly);
				break;

				case 2:
				size(maxi(x+1, 160), maxi(y+1, 100));
				break;
			}
		}
		else
		{
			int max=((pos.w*pos.w+pos.h*pos.h)*7)>>3;
			int	n=x*x+y*y;
			if(n>max)
				cursor(cursorSIZENWSE);
			else
				cursor(cursorCROSS);
		}
		return TRUE;

		case mouseLUP:
		if(bac)
		{
			bac=0;
			mouseCapture(FALSE);
		}
		return TRUE;

		case mouseRDOWN:
		size(320, 240);
		return TRUE;
	}
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Awdispatch::pulse()
{
	disp->getPreview(bitmap);
	repaint();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static int						count=0;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static void init()
{
	if(!count)
	{
	}
	count++;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static void end()
{
	count--;
	if(count==0)
	{
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Adispatch::getPreview(Abitmap *bitmap)
{
	static char		*text[]={ "IN 1", "IN 2", "IN 3", "IN 4", "IN 5", "IN 6", "IN 7", "IN 8", "OUT 1", "OUT 2", "OUT 3", "OUT 4"};
	static bool		fb[]={true, true, true, true, true, true, true, true, false, false, false, false};
	static int		fbpos[]={0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3};
	Adispatch		*disp=this;
	AdispatchFront	*front=(AdispatchFront *)disp->front;
	AdispatchBack	*back=(AdispatchBack *)disp->back;
	int				i;
	int				wd=(bitmap->w/3)+1;
	int				hd=bitmap->h/4;
	int				ws=disp->getVideoWidth();
	int				hs=(disp->getVideoHeight()*3)/4;
	int				ys=(disp->getVideoHeight()-hs)/2;

	{
		int	x,y;
		int	xd=0;
		int	n=0;

		for(x=0; x<2; x++)
		{
			int	yd=0;
			for(y=0; y<4; y++)
			{
				Avideo	*in=back->in[n++];
				in->enter(__FILE__,__LINE__);
				{
					Abitmap	*bi=in->getBitmap();
					if(bi)
						bitmap->set(xd, yd, wd, hd, 0, ys, ws, hs, bi, bitmapNORMAL, bitmapNORMAL);
					else
						random(bitmap, xd, yd, wd+wd, yd+hd);
				}
				in->leave();
				yd+=hd;
			}
			xd+=wd;
		}
	}


	{
		int	xd=wd*2;
		int	yd=0;

		for(i=0; i<4; i++)
		{
			int		n=front->source[i]->get();
			Avideo	*in=back->in[n];
			in->enter(__FILE__,__LINE__);
			{
				Abitmap	*bi=in->getBitmap();
				if(bi)
					bitmap->set(xd, yd, wd, hd, 0, ys, ws, hs, bi, bitmapNORMAL, bitmapNORMAL);
				else
					random(bitmap, xd, yd, xd+wd, yd+hd);
			}
			in->leave();
			yd+=hd;
		}
	}

	{
		int	i;
		int	v=0;
		for(i=0; i<3; i++)
		{
			v+=wd;
			bitmap->line(v, 0, v, bitmap->h, 0xff000000);
			bitmap->line(v-1, 0, v-1, bitmap->h, 0xff000000);
		}
	}
	{
		int	i;
		int	v=0;
		for(i=0; i<4; i++)
		{
			v+=hd;
			bitmap->line(0, v, bitmap->w, v, 0xff000000);
			bitmap->line(0, v-1, bitmap->w, v-1, 0xff000000);
		}
	}

	{
		Afont	*f=alib.getFont(fontTERMINAL06);
		int	x,y;
		int	n=0;
		int	xd=5;
		for(x=0; x<3; x++)
		{
			int	yd=5;
			for(y=0; y<4; y++)
			{
				int	ydd=yd+10;
				f->set(bitmap, xd, yd, text[n], 0xff00ff00, 0xff404040);
				if(fb[n])	// IN
				{
					Avideo	*in=back->in[fbpos[n]];
					Atable	*table=disp->getTable();
					table->synchronize.enter(__FILE__,__LINE__);
					in->enter(__FILE__,__LINE__);
					{
						Apin	*out=in->getConnectedPin();
						if(out)
						{
							char	str[1024];
							sprintf(str, "%s/%s", out->effect->name, out->name);
							strupr(str);
							{
								int	nm=mini(1023, (wd-20)/f->w);
								str[nm]=0;
							}
							f->set(bitmap, xd, ydd, str, 0xffffff00, 0xff404040);
						}
					}
					in->leave();
					table->synchronize.leave();
				}
				else		// OUT
				{
					Avideo	*out=back->out[fbpos[n]];
					Atable	*table=disp->getTable();
					table->synchronize.enter(__FILE__,__LINE__);
					out->enter(__FILE__,__LINE__);
					{
						Aconnect	*c=(Aconnect *)table->connects->fchild;
						while(c)
						{
							if(c->out==out)
							{
								char	str[1024];
								sprintf(str, "%s/%s", c->in->effect->name, c->in->name);
								strupr(str);
								{
									int	nm=mini(1023, (wd-20)/f->w);
									str[nm]=0;
								}
								f->set(bitmap, xd, ydd, str, 0xffffff00, 0xff404040);
								ydd+=10;
								if(ydd-yd>hd-14)
									break;
							}
							c=(Aconnect *)c->next;
						}
					}
					out->leave();
					table->synchronize.leave();
				}
				yd+=hd;
				n++;
			}
			xd+=wd;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Adispatch::Adispatch(QIID qiid, char *name, AeffectInfo *info, Acapsule *capsule) : Aeffect(qiid, name, info, capsule)
{
	init();

	front=new AdispatchFront(qiid, "dispatch front", this, 50);
	front->setTooltips("dispatch module");
	back=new AdispatchBack(qiid, "dispatch back", this, 50);
	back->setTooltips("dispatch module");

	oscPreview=new AoscNode("preview", this, ",j", "preview");

	settings(false);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Adispatch::~Adispatch()
{
	AdispatchFront	*front=(AdispatchFront *)this->front;

	if(front->win)
		front->win->timer();

	delete(oscPreview);

	end();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool Adispatch::save(class Afile *f)
{
	bool	b=((AdispatchFront *)front)->bwin->isChecked();
	f->write(&b, sizeof(b));
	return true;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool Adispatch::load(class Afile *f)
{
	AdispatchFront	*front=(AdispatchFront *)this->front;
	bool			b=false;
	bool			oldb=front->bwin->isChecked();
	f->read(&b, sizeof(b));
	if(b!=oldb)
	{
		front->bwin->setChecked(b);
		front->notify(front->bwin, nyCHANGE, (dword)b);
	}
	return true;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool Adispatch::oscMessage(class AoscMessage *reply, class AoscMessage *msg, class AoscNode *onode, int action)
{
	switch(action)
	{
		case oscGETVALUE:
		if(onode==oscPreview)
		{
			Abitmap *b=new Abitmap(400, 300);
			getPreview(b);
			reply->add(new AoscBitmap(b));
			return true;	// reply used
		}
		break;
	}
	return Aeffect::oscMessage(reply, msg, onode, action);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Adispatch::settings(bool emergency)
{
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Adispatch::action(double time, double dtime, double beat, double dbeat)
{
	//int				w=table->videoW;
	//int				h=table->videoH;
	//int				mw=w>>1;
	//int				mh=h>>1;
	AdispatchFront	*front=(AdispatchFront *)this->front;
	AdispatchBack	*back=(AdispatchBack *)this->back;
	int				i;
	int				check[DISPATCH_IN];
	
	memset(check, 0, sizeof(check));

	for(i=0; i<DISPATCH_OUT; i++)
	{
		int	src=front->source[i]->get();
		check[src]|=1<<i;
		{	// video
			Avideo			*out=back->out[i];
			Avideo			*in=back->in[src];

			out->enter(__FILE__,__LINE__);
			in->enter(__FILE__,__LINE__);
			{
				Abitmap	*bo=out->getBitmap();
				Abitmap	*bi=in->getBitmap();
				if(bo&&bi)
					bo->set(0, 0, bi, bitmapDEFAULT, bitmapDEFAULT);
			}
			in->leave();
			out->leave();
		}
	}

	for(i=0; i<DISPATCH_IN; i++)
	{
		Asample			*ain=back->ain[i];

		ain->enter(__FILE__,__LINE__);
		{
			short	buffer[8182*2];
			int		avaible=ain->avaible();
			while(avaible)
			{
				int	a=mini(avaible, 8182);
				ain->getBuffer(buffer, a);
				{
					int	j;
					for(j=0; j<DISPATCH_OUT; j++)
					{
						if(check[i]&(1<<j))
						{
							Asample	*aout=back->aout[j];
							aout->enter(__FILE__,__LINE__);
							aout->addBuffer(buffer, a);
							aout->leave();
						}
					}
				}
				avaible-=a;
			}
		}
		ain->leave();
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void AdispatchFront::paint(Abitmap *b)
{
	b->set(0, 0, back, bitmapDEFAULT, bitmapDEFAULT);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static QIID qiidsrc[DISPATCH_OUT]={0xcda50dfee6321871, 0xf4f5b7d5d65d0fa5, 0x85e3105280fb1b00, 0xed482a70b1fa0800};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

AdispatchFront::AdispatchFront(QIID qiid, char *name, Adispatch *e, int h) : AeffectFront(qiid, name, e, h)
{
	int		i;
	Aresobj	o=resource.get(MAKEINTRESOURCE(PNG_DISPATCH), "PNG");
	back=new Abitmap(&o);

	for(i=0; i<DISPATCH_OUT; i++)
	{
		char	name[128];
		sprintf(name, "source # %d", i+1);
		source[i]=new Aselect(MKQIID(qiid, qiidsrc[i]), name, this, 13+88*i, 8, 4, 2, &resource.get(MAKEINTRESOURCE(PNG_DISPATCH_SOURCES), "PNG"), 16, 16);
		source[i]->setTooltips(name);
		source[i]->set(0);
		source[i]->show(TRUE);
	}

	bwin=new Abutton("bwin", this, 362, (pos.h-16)>>1, 54, 16, "PREVIEW", Abutton::btCAPTION|Abutton::bt2STATES|Abutton::btALIGNCENTER);
	bwin->setTooltips("display preview window");
	bwin->colorBACKNORMAL=0xff4A5C56;
	bwin->show(true);
	bwin->setChecked(false);

	win=NULL;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

AdispatchFront::~AdispatchFront()
{
	int	i;
	delete(bwin);
	if(win)
		delete(win);
	delete(back);
	for(i=0; i<DISPATCH_OUT; i++)
		delete(source[i]);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool AdispatchFront::notify(Anode *o, int event, dword p)
{
	switch(event)
	{
		case nyCHANGE:
		if(o==bwin)
		{
			if(bwin->isChecked())
			{
				if(!win)
				{
					win=new Awdispatch("wdispatch", 400, 10, 320, 240, (Adispatch *)effect);
					if(win)
						win->show(true);
				}
			}
			else if(win)
			{
				win->destroy();
				win=NULL;
			}

		}
		break;
	}
	return AeffectFront::notify(o, event, p);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

QIID	qiidout[DISPATCH_OUT]={ 0x478fa9b9ebaf7d40, 0xba03a9d94938d528, 0x5286b0f7e2d5d6d4, 0xf7a2a073177c05b8};
QIID	qiidin[DISPATCH_IN]={	0xfe4d6dd2feea0680, 0xa800e779501c6fec, 0x1e87937727f5b319, 0x0073530d27d34000, 
								0x69f7655516df2d50, 0x55b13ca2c2a01334, 0x989cbfe0257f6410, 0x873d88ac14e36d10};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

AdispatchBack::AdispatchBack(QIID qiid, char *name, Adispatch *e, int h) : AeffectBack(qiid, name, e, h)
{
	int		i;
	Aresobj	o=resource.get(MAKEINTRESOURCE(PNG_DISPATCH2), "PNG");
	back=new Abitmap(&o);

	for(i=0; i<DISPATCH_OUT; i++)
	{
		char	name[128];

		sprintf(name, "video output # %d", i+1);
		out[i]=new Avideo(MKQIID(qiid, qiidout[i]), name, this, pinOUT, 2+pos.w-20*(DISPATCH_OUT-i), 10);
		out[i]->setTooltips(name);
		out[i]->show(TRUE);

		sprintf(name, "audio output # %d", i+1);
		aout[i]=new Asample(MKQIID(qiid, qiidout[i]^0x69a8d5e25a4a0050), name, this, pinOUT, 2+pos.w-20*(DISPATCH_OUT-i), 30);
		aout[i]->setTooltips(name);
		aout[i]->show(TRUE);
	}

	for(i=0; i<DISPATCH_IN; i++)
	{
		char	name[128];

		sprintf(name, "video input # %d", i+1);
		in[i]=new Avideo(MKQIID(qiid, qiidin[i]), name, this, pinIN, 10+i*20, 10);
		in[i]->setTooltips(name);
		in[i]->show(TRUE);

		sprintf(name, "audio input # %d", i+1);
		ain[i]=new Asample(MKQIID(qiid, qiidin[i]^0x69a8d5e25a4a0050), name, this, pinIN, 10+i*20, 30);
		ain[i]->setTooltips(name);
		ain[i]->show(TRUE);
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

AdispatchBack::~AdispatchBack()
{
	int	i;
	delete(back);
	for(i=0; i<DISPATCH_IN; i++)
	{
		delete(in[i]);
		delete(ain[i]);
	}
	for(i=0; i<DISPATCH_OUT; i++)
	{
		delete(out[i]);
		delete(aout[i]);
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void AdispatchBack::paint(Abitmap *b)
{
	b->set(0, 0, back, bitmapDEFAULT, bitmapDEFAULT);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Aeffect * AdispatchInfo::create(QIID qiid, char *name, Acapsule *capsule)
{
	return new Adispatch(qiid, name, this, capsule);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class Aplugz * dispatchGetInfo()
{
	return new AdispatchInfo("dispatchInfo", &Adispatch::CI, "dispatch", "dispatch module - video dispatcher");
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
