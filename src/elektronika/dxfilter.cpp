/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//	DXFILTER.CPP				(c)	YoY'01						WEB: www.aestesis.org
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include						<dshow.h>
#include						"../alib/defSampleGrabber.h"
//#include						<qedit.h>
#include						"resource.h"
#include						"dxfilter.h"
//#include						"leffect.h"
//#include						"dxsend.h"
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

ACI								AdxfilterInfo::CI	= ACI("AdxfilterInfo",	GUID(0x11111112,0x00000090), &AeffectInfo::CI, 0, NULL);
ACI								Adxfilter::CI		= ACI("Adxfilter",		GUID(0x11111112,0x00000091), &Aeffect::CI, 0, NULL);
ACI								AdxfilterFront::CI	= ACI("AdxfilterFront",	GUID(0x11111112,0x00000092), &AeffectFront::CI, 0, NULL);
ACI								AdxfilterBack::CI	= ACI("AdxfilterBack",	GUID(0x11111112,0x00000093), &AeffectBack::CI, 0, NULL);

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#define							SAFE_RELEASE(pObject) if(pObject){ pObject->Release(); pObject = NULL;}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static void MyFreeMediaType(AM_MEDIA_TYPE& mt)
{
    if (mt.cbFormat != 0)
    {
        CoTaskMemFree((PVOID)mt.pbFormat);
        mt.cbFormat = 0;
        mt.pbFormat = NULL;
    }
    if (mt.pUnk != NULL)
    {
        // Unecessary because pUnk should not be used, but safest.
        mt.pUnk->Release();
        mt.pUnk = NULL;
    }
}

static void MyDeleteMediaType(AM_MEDIA_TYPE *pmt)
{
    if (pmt != NULL)
    {
        MyFreeMediaType(*pmt); // See FreeMediaType for the implementation.
        CoTaskMemFree(pmt);
    }
}

static bool isPin(IBaseFilter *pFilter, PIN_DIRECTION PinDir, GUID mediatype)
{
    IEnumPins  *pEnum;
    IPin       *pPin;

    pFilter->EnumPins(&pEnum);
    while(pEnum->Next(1, &pPin, 0) == S_OK)
    {
        PIN_DIRECTION PinDirThis;
        pPin->QueryDirection(&PinDirThis);
		/*
		{
			PIN_INFO	pinfo;
			char		*name;
			pPin->QueryPinInfo(&pinfo);
			UnicodeToAnsi(pinfo.achName, &name);
			free(name);
		}
		*/
        if (PinDir == PinDirThis)
        {
			IEnumMediaTypes	*pEnumMT;
			AM_MEDIA_TYPE	*pmt;

			if(pPin->EnumMediaTypes(&pEnumMT)==S_OK)
			{
				while(pEnumMT->Next(1, &pmt, 0)==S_OK)
				{
					if(pmt->majortype==mediatype)
					{
						MyDeleteMediaType(pmt);
						pEnumMT->Release();
						pEnum->Release();
						return true;
					}
					MyDeleteMediaType(pmt);
 				}
				pEnumMT->Release();
			}
        }
        pPin->Release();
    }
    pEnum->Release();
    return false;  
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static HRESULT UnicodeToAnsi(LPCOLESTR pszW, LPSTR* ppszA)
{

    ULONG cbAnsi, cCharacters;
    DWORD dwError;

    // If input is null then just return the same.
    if (pszW == NULL)
    {
        *ppszA = NULL;
        return NOERROR;
    }

    cCharacters = wcslen(pszW)+1;
    // Determine number of bytes to be allocated for ANSI string. An
    // ANSI string can have at most 2 bytes per character (for Double
    // Byte Character Strings.)
    cbAnsi = cCharacters*2;

    // Use of the OLE allocator is not required because the resultant
    // ANSI  string will never be passed to another COM component. You
    // can use your own allocator.
    *ppszA = (LPSTR) malloc(cbAnsi);
    if (NULL == *ppszA)
        return E_OUTOFMEMORY;

    // Convert to ANSI.
    if (0 == WideCharToMultiByte(CP_ACP, 0, pszW, cCharacters, *ppszA,
                  cbAnsi, NULL, NULL))
    {
        dwError = GetLastError();
        CoTaskMemFree(*ppszA);
        *ppszA = NULL;
        return HRESULT_FROM_WIN32(dwError);
    }
    return NOERROR;

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class IdxAudioCB : public ISampleGrabberCB
{

	HRESULT	__stdcall			SampleCB					(double,struct IMediaSample *) {return 0;}
	HRESULT __stdcall			BufferCB					(double SampleTime, BYTE *pBuffer, long BufferLen);

private:
	//! COM reference count
	ULONG _ref_count;

public:
	//! Return a ptr to a different COM interface to this object
	HRESULT APIENTRY QueryInterface( REFIID iid, void** ppvObject )
	{
		// Match the interface and return the proper pointer
		if ( iid == IID_IUnknown) {
			*ppvObject = dynamic_cast<IUnknown*>( this );
		} else if ( iid == IID_ISampleGrabberCB ) {
			*ppvObject = dynamic_cast<ISampleGrabberCB*>( this );
		} else {
			// It didn't match an interface
			*ppvObject = NULL;
			return E_NOINTERFACE;
		}

		// Increment refcount on the pointer we're about to return
		this->AddRef();
		// Return success
		return S_OK;
	}

	//! Increment ref count
	ULONG APIENTRY AddRef()
	{
		return ( ++ _ref_count );
	}

	//! Decrement ref count
	ULONG APIENTRY Release()
	{
		return ( -- _ref_count );
	}
public:
								IdxAudioCB					();
								~IdxAudioCB					();
	
	Asection					section;								
	Abuffer						*buffer;
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

IdxAudioCB::IdxAudioCB()
{
	buffer=new Abuffer("audio", 44100);
	AddRef();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

IdxAudioCB::~IdxAudioCB()
{
	if(buffer)
		delete(buffer);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

HRESULT __stdcall IdxAudioCB::BufferCB(double SampleTime, BYTE *pBuffer, long BufferLen)
{	
	section.enter(__FILE__,__LINE__);
	buffer->write(pBuffer, BufferLen);
	section.leave();
	return 0;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
class IdxSource : public IBaseFilter
{

private:
	//! COM reference count
	ULONG _ref_count;

public:
	//! Return a ptr to a different COM interface to this object
	HRESULT APIENTRY QueryInterface( REFIID iid, void** ppvObject )
	{
		// Match the interface and return the proper pointer
		if ( iid == IID_IUnknown) {
			*ppvObject = dynamic_cast<IUnknown*>( this );
		} else if ( iid == IID_IBaseFilter ) {
			*ppvObject = dynamic_cast<IBaseFilter*>( this );
		} else {
			// It didn't match an interface
			*ppvObject = NULL;
			return E_NOINTERFACE;
		}

		// Increment refcount on the pointer we're about to return
		this->AddRef();
		// Return success
		return S_OK;
	}

	//! Increment ref count
	ULONG APIENTRY AddRef()
	{
		return ( ++ _ref_count );
	}

	//! Decrement ref count
	ULONG APIENTRY Release()
	{
		return ( -- _ref_count );
	}
public:
								IdxSource					();
								~IdxSource					();
	
	Asection					section;								
	Abuffer						*buffer;
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

IdxSource::IdxSource()
{
	buffer=new Abuffer("audio", 44100);
	AddRef();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

IdxSource::~IdxSource()
{
	if(buffer)
		delete(buffer);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

*/
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class Adxgfx
{
public:
								Adxgfx						(CLSID	*clsid);
	virtual						~Adxgfx						();
								
	bool						create						(CLSID	*clsid);

	bool						isOK						()	{ return ok; }

protected:
	bool						ok;
	IGraphBuilder				*graph;
	IMediaControl				*media;
	IBaseFilter					*grab_bf;
	IdxAudioCB					*audioCB;

	IBaseFilter					*send;
	IBaseFilter					*filter;
	ISampleGrabber				*grab;

	bool						initGFX						();
	void						closeGFX					();
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Adxgfx::Adxgfx(CLSID *clsid)
{
	ok=false;
	if(initGFX())
	{
		if(create(clsid))
		{
			ok=true;
			return;
		}
	}
	closeGFX();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Adxgfx::~Adxgfx()
{
	closeGFX();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool Adxgfx::create(CLSID *clsid)
{
	if(CoCreateInstance(*clsid, NULL, CLSCTX_INPROC_SERVER, IID_IBaseFilter, reinterpret_cast<PVOID *>(&filter)))
		return false;
	graph->AddFilter(filter, L"filter effect");
	return true;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Adxgfx::closeGFX()
{
	SAFE_RELEASE(graph);
	SAFE_RELEASE(media);
	SAFE_RELEASE(grab);
	SAFE_RELEASE(grab_bf);
	SAFE_RELEASE(filter);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool Adxgfx::initGFX()
{
	HRESULT			hr;
	AM_MEDIA_TYPE	mt;

	graph=NULL;
	media=NULL;
	grab=NULL;
	grab_bf=NULL;
	filter=NULL;

	hr = CoCreateInstance(CLSID_FilterGraph, NULL, CLSCTX_INPROC_SERVER,IID_IGraphBuilder,(void**)&graph);
	if(hr!=S_OK)
		return false;

    hr = graph->QueryInterface(IID_IMediaControl, (void **) & media);
	if(hr!=S_OK)
		return false;

	hr = CoCreateInstance(CLSID_SampleGrabber, NULL, CLSCTX_INPROC_SERVER, IID_IBaseFilter, reinterpret_cast<void**>(&grab_bf));
	if(hr!=S_OK)
		return false;

	hr = grab_bf->QueryInterface(IID_ISampleGrabber, reinterpret_cast<void**>(&grab));
	if(hr!=S_OK)
		return false;

	hr = graph->AddFilter(grab_bf, L"SampleGrabber");
	if(hr!=S_OK)
		return false;

	audioCB=new IdxAudioCB();
	grab->SetCallback(audioCB, 1);

	memset(&mt, 0, sizeof(mt));
	mt.majortype = MEDIATYPE_Audio;
    mt.subtype = MEDIASUBTYPE_PCM;

	hr = grab->SetMediaType(&mt);
	if(hr!=S_OK)
		return false;

	grab->SetBufferSamples(true);
	if(hr!=S_OK)
		return false;
/*
	hr = CoCreateInstance(CLSID_NullRenderer, NULL, CLSCTX_INPROC_SERVER, IID_IBaseFilter, reinterpret_cast<void**>(&m_pNullSound));
	if(hr!=S_OK)
		return false;

	hr = m_pGraph->AddFilter(m_pNullSound, L"NullRenderer Sound");
	if(hr!=S_OK)
		return false;
*/
/*
	hr = CoCreateInstance(CLSID_SampleSender, NULL, CLSCTX_INPROC_SERVER, IID_IBaseFilter, reinterpret_cast<void**>(&send));
	if(hr!=S_OK)
		return false;

	hr = graph->AddFilter(send, L"send filter");
	if(hr!=S_OK)
		return false;
*/
	return true;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Adxfilter::Adxfilter(QIID qiid, char *name, AeffectInfo *info, Acapsule *capsule) : Aeffect(qiid, name, info, capsule)
{
	memset(dev, 0, sizeof(dev));
	ndev=0;
	m_pSysDevEnum=NULL;
	sectionDX.enter(__FILE__,__LINE__);
	dx=NULL;
	sectionDX.leave();
	bOK=initDX();

	front=new AdxfilterFront(qiid, "dxfilter front", this, 50);
	front->setTooltips("dx filter module");
	back=new AdxfilterBack(qiid, "dxfilter back", this, 50);
	back->setTooltips("dx filter module");
}

Adxfilter::~Adxfilter()
{
	sectionDX.enter(__FILE__,__LINE__);
	if(dx)
	{
		delete(dx);
		dx=NULL;
	}
	sectionDX.leave();
	closeDX();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool Adxfilter::load(class Afile *f)
{
	return ((AdxfilterFront *)front)->load(f);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool Adxfilter::save(class Afile *f)
{
	return ((AdxfilterFront *)front)->save(f);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool Adxfilter::initDX()
{
	HRESULT hr;

    
    m_pSysDevEnum = NULL;
    hr = CoCreateInstance(CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC, IID_ICreateDevEnum,  (void **)&m_pSysDevEnum);

    //hr=CoCreateInstance(CLSID_FilterMapper2, NULL, CLSCTX_INPROC, IID_IFilterMapper2, (void **) &mapper);
	if(hr!=S_OK)
	{
		return false;
	}

	if(!getFilters())
	{
		SAFE_RELEASE(m_pSysDevEnum);
		return false;
	}

	return true;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Adxfilter::closeDX()
{
	if(bOK)
	{
		int	i;
		for(i=0; i<ndev; i++)
			free(dev[i].name);
		ndev=0;
		SAFE_RELEASE(m_pSysDevEnum);
		bOK=false;
	}
}

bool Adxfilter::getFilters()
{
	static char		*list[]={"sony", "cfx", "cakewalk" };
    IEnumMoniker	*pEnumCat = NULL;
	HRESULT			hr;
/*
    &CLSID_AudioInputDeviceCategory, TEXT("Audio Capture Devices"),
    &CLSID_AudioCompressorCategory,  TEXT("Audio Compressors"),
    &CLSID_AudioRendererCategory,    TEXT("Audio Renderers"),
    &CLSID_LegacyAmFilterCategory,   TEXT("DirectShow Filters"),
    &CLSID_MidiRendererCategory,     TEXT("Midi Renderers"),
    &CLSID_VideoInputDeviceCategory, TEXT("Video Capture Devices"),
    &CLSID_VideoCompressorCategory,  TEXT("Video Compressors"),
*/

    hr = m_pSysDevEnum->CreateClassEnumerator(CLSID_LegacyAmFilterCategory, &pEnumCat, 0);
    if FAILED(hr)
        return false;

    // Enumerate all filters using the category enumerator

	{
	    IMoniker	*pMoniker=NULL;
		ULONG		cFetched;
		VARIANT		varName={0};
		VARIANT		varFilterClsid;
		int			nFilters=0;

		while(pEnumCat->Next(1, &pMoniker, &cFetched) == S_OK)
		{
			IPropertyBag	*pPropBag=NULL;
			IBaseFilter		*bf=NULL;
			IBindCtx		*pbc=NULL;
			bool			oki=false;

			// Associate moniker with a file
			hr = pMoniker->BindToStorage(0, 0, IID_IPropertyBag, (void **)&pPropBag);
			if (FAILED(hr))
			{
				SAFE_RELEASE(pMoniker);
				continue;
			}

			varName.vt = VT_BSTR;
			hr=pPropBag->Read(L"FriendlyName", &varName, 0);
			if (FAILED(hr))
			{
				SAFE_RELEASE(pPropBag);
				SAFE_RELEASE(pMoniker);
				continue;
			}

			UnicodeToAnsi(varName.bstrVal, &dev[ndev].name);
			SysFreeString(varName.bstrVal);

			/*
			strlwr(dev[ndev].name);
			{
				int	i;
				for(i=0; i<countof(list); i++)
				{
					if(strstr(dev[ndev].name, list[i]))
					{
						oki=true;
						break;
					}
				}
			}
			*/
			oki=true;

			if(oki)
			{
				varFilterClsid.vt = VT_BSTR;
				hr = pPropBag->Read(L"CLSID", &varFilterClsid, 0);
				if(hr!=S_OK)
				{
					SAFE_RELEASE(pPropBag);
					SAFE_RELEASE(pMoniker);
					continue;
				}

				if(CLSIDFromString(varFilterClsid.bstrVal, &dev[ndev].clsid) == S_OK)
					ndev++;
				SysFreeString(varFilterClsid.bstrVal);

			}

			SAFE_RELEASE(pPropBag);
		    SAFE_RELEASE(pMoniker);
        }
       
        // Cleanup interfaces
    }

    SAFE_RELEASE(pEnumCat);
	return true;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool AdxfilterFront::load(class Afile *f)
{
	char	drv[1024];
	if(f->readString(drv))
	{
		Aitem	*i=(Aitem *)driverItems->fchild;
		while(i)
		{
			if(!strcmp(i->name, drv))
			{
				Adxfilter	*si=(Adxfilter *)effect;
				drivers->setCurrentByData(i->data);
				if(si->bOK)
				{
				}
				else
					drivers->setCurrentByData(666);
				break;
			}
			i=(Aitem *)i->next;
		}
		return true;
	}
	return false;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool AdxfilterFront::save(class Afile *f)
{
	Aitem	*i=drivers->getCurrent();
	if(i)
	{
		if(!f->writeString(i->name))
			return false;
	}
	else
	{
		if(!f->writeString("[none]"))
			return false;
	}
	return true;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

AdxfilterFront::AdxfilterFront(QIID qiid, char *name, Adxfilter *e, int h) : AeffectFront(qiid, name, e, h)
{
	Aresobj	o=resource.get(MAKEINTRESOURCE(PNG_SOUNDINPUT), "PNG");
	back=new Abitmap(&o);

	driverItems=new Aitem("dxfilter", "dxfilter");
	if(e->bOK)
	{
		int	i;
		for(i=0; i<e->ndev; i++)
			new Aitem(e->dev[i].name, e->dev[i].name, driverItems, i);
		new Aitem("[none]", "no input", driverItems, 666);
	}
	driverItems->sort();
	drivers=new Alist("dxfilter list", this, 16, (pos.h-20)>>1, 250-32, 20, driverItems);
	if(e->bOK)
		drivers->setCurrentByData(666);
	drivers->setTooltips("dx filter selector");
	drivers->show(TRUE);

	//timer(100);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

AdxfilterFront::~AdxfilterFront()
{
	delete(back);
	delete(drivers);
	delete(driverItems);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void AdxfilterFront::paint(Abitmap *b)
{
	b->set(0, 0, back, bitmapDEFAULT, bitmapDEFAULT);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool AdxfilterFront::notify(Anode *o, int event, dword p)
{
	switch(event)
	{
		case nyCHANGE:
		{
			Adxfilter	*si=(Adxfilter *)effect;
			if(si->bOK)
			{
				//AdxfilterBack	*sib=(AdxfilterBack *)si->back;
				if(o==drivers)
				{
					si->sectionDX.enter(__FILE__,__LINE__);
					if(si->dx)
						delete(si->dx);
					si->dx=new Adxgfx(&si->dev[drivers->getCurrentData()].clsid);
					if(!si->dx->isOK())
					{
						char	str[512];
						delete(si->dx);
						si->dx=NULL;
						sprintf(str, "can't create dx filter \"%s\"", si->dev[drivers->getCurrentData()].name);
						notify(this, nyERROR, (dword)str);
					}
					si->sectionDX.leave();

					//si->dsoundStop();
					//memset(sib->out->sample, 0, sib->out->size*4);
					//if(!si->dsoundStart(drivers->getCurrentData()))
					//{
					//	notify(this, nyERROR, (dword)"can't start audio output [select another device or close other audio software]");
					//	drivers->setCurrentByData(666);
					//}
				}
			}
		}
		return TRUE;
	}
	return AeffectFront::notify(o, event, p);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

AdxfilterBack::AdxfilterBack(QIID qiid, char *name, Adxfilter *e, int h) : AeffectBack(qiid, name, e, h)
{
	Aresobj	o=resource.get(MAKEINTRESOURCE(PNG_SOUNDINPUT2), "PNG");
	back=new Abitmap(&o);

	in=new Asample(MKQIID(qiid, 0x015e8deeb52a071f), "audio in", this, pinIN, 10, 10);
	in->setTooltips("audio intput");
	in->show(TRUE);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

AdxfilterBack::~AdxfilterBack()
{
	delete(back);
	delete(in);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void AdxfilterBack::paint(Abitmap *b)
{
	b->set(0, 0, back, bitmapDEFAULT, bitmapDEFAULT);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Aeffect * AdxfilterInfo::create(QIID qiid, char *name, Acapsule *capsule)
{
	return new Adxfilter(qiid, name, this, capsule);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class Aplugz * dxfilterGetInfo()
{
	return new AdxfilterInfo("dxfilterInfo", &Adxfilter::CI, "dx filter", "dx filter module");
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
