/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include							"export.h"
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//	EF3D-NODE.CPP					(c)	YoY'05						WEB: www.aestesis.org
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include							"ef3d-node.h"
#include							<math.h>
#include							<d3d9.h>
#include							<D3dx9mesh.h>
#include							<assert.h>
#include							<stdio.h>
#include							<io.h>
#include							<direct.h>
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Ad3dNode::Ad3dNode(char *name, Ad3dNode *father)
{
	d3dev=null;
	D3DXMatrixIdentity(&matrice);
	if(name&&name[0])
		this->name=strdup(name);
	else
		this->name=NULL;
	this->father=NULL;
	next=NULL;
	prev=NULL;
	fchild=NULL;
	lchild=NULL;
	if(father)
		father->add(this);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Ad3dNode::~Ad3dNode()
{
	release();
	if(name)
		free(name);
	if(father)
		father->del(this);
	while(fchild)
		delete(fchild);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool Ad3dNode::init(IDirect3DDevice9 *d3dev)
{
	assert(this->d3dev==null);
	this->d3dev=d3dev;
	d3dev->AddRef();
	return true;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Ad3dNode::release()
{
	if(d3dev)
	{
		d3dev->Release();
		d3dev=null;
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Ad3dNode::setName(char *name)
{
	if(this->name)
		free(this->name);
	if(name&&name[0])
		this->name=strdup(name);
	else
		this->name=NULL;
		
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Ad3dNode::clear()
{
	while(fchild)
		delete(fchild);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Ad3dNode::add(Ad3dNode *o)
{
	Ad3dNode	*os=NULL;
	Ad3dNode	*s=fchild;
	assert((o->father==NULL)||(o->father==this));
	o->father=this;
	while(s)
	{
		if(!(s->state&stateTOP))
			break;
		os=s;
		s=s->next;
	}
	if(os)
	{
		if(os->next)
		{
			o->next=os->next;
			os->next->prev=o;
			os->next=o;
			o->prev=os;
		}
		else
		{
			o->prev=os;
			o->next=NULL;
			os->next=o;
			lchild=o;
		}
	}
	else
	{
		if(fchild)
		{
			o->next=fchild;
			o->prev=NULL;
			fchild->prev=o;
			fchild=o;
		}
		else
		{
			o->prev=NULL;
			o->next=NULL;
			fchild=lchild=o;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Ad3dNode::del(Ad3dNode *o)
{
	if(o->prev)
		o->prev->next=o->next;
	else
		fchild=o->next;
	if(o->next)
		o->next->prev=o->prev;
	else
		lchild=o->prev;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int Ad3dNode::count()
{
	Ad3dNode	*i=fchild;
	int		n=0;
	while(i)
	{
		i=i->next;
		n++;
	}
	return n;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool Ad3dNode::initAll(IDirect3DDevice9 *d3dev)
{
	bool		b;

	b=init(d3dev);

	if(b)
	{
		Ad3dNode	*n=fchild;
		while(n)
		{
			if(!n->initAll(d3dev))
			{
				assert(NULL);
				b=false;
				break;
			}
			n=n->next;
		}
	}

	return b;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Ad3dNode::releaseAll()
{
	Ad3dNode	*n=fchild;
	while(n)
	{
		n->releaseAll();
		n=n->next;
	}
	release();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool Ad3dNode::renderAll(double beat, dword color)
{
	bool		b;
	D3DXMATRIX	matWorld;
	D3DXMATRIX	matOld;

	d3dev->GetTransform(D3DTS_WORLD, &matOld);
	D3DXMatrixMultiply(&matWorld, &matOld, &matrice);
	d3dev->SetTransform(D3DTS_WORLD, &matWorld);

	b=render(beat, color);

	if(b)
	{
		Ad3dNode	*n=fchild;
		while(n)
		{
			if(!n->renderAll(beat, color))
			{
				assert(NULL);
				b=false;
				break;
			}
			n=n->next;
		}
	}

	d3dev->SetTransform(D3DTS_WORLD, &matOld);
	return b;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	
struct CUBE_CUSTOMVERTEX
{
    D3DXVECTOR3 position; // The 3-D position for the vertex.
    D3DXVECTOR3 normal;   // The surface normal for the vertex.
    dword		color;
    float		u,v;
};

#define CUBE_D3DFVF					(D3DFVF_XYZ|D3DFVF_NORMAL|D3DFVF_DIFFUSE|D3DFVF_TEX1)
#define CUBE_NBVERTEX				(36)
#define	CUBE_VBUFSIZE				(sizeof(CUBE_CUSTOMVERTEX)*CUBE_NBVERTEX)

static float cube_point[8][3]=
{
	{ -1, -1, -1 },
	{ -1,  1, -1 },
	{  1,  1, -1 },
	{  1, -1, -1 },
	{ -1, -1,  1 },
	{ -1,  1,  1 },
	{  1,  1,  1 },
	{  1, -1,  1 }
};

static int cube_face[12][3]=
{
	{ 0, 1, 2 },
	{ 0, 2, 3 },
	{ 3, 2, 6 },
	{ 3, 6, 7 },
	{ 7, 6, 5 },
	{ 7, 5, 4 },
	{ 4, 5, 1 },
	{ 4, 1, 0 },
	{ 1, 5, 6 },
	{ 1, 6, 2 },
	{ 3, 7, 4 },
	{ 3, 4, 0 }
};

static int cube_uv[6][2]=
{
	{ 0, 1 },
	{ 0, 0 },
	{ 1, 0 },
	{ 0, 1 },
	{ 1, 0 },
	{ 1, 1 }
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Ad3dCube::Ad3dCube(char *name, Ad3dNode *father) : Ad3dNode(name, father)
{
	texture=null;
	vb=null;
	size=1.f;
	xsize=1.f;
	ysize=1.f;
	zsize=1.f;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Ad3dCube::~Ad3dCube()
{
	setTexture(null);
	release();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool Ad3dCube::init(IDirect3DDevice9 *d3dev)
{
	if(!Ad3dNode::init(d3dev))
		return false;
	if(d3dev->CreateVertexBuffer(CUBE_VBUFSIZE, 0, CUBE_D3DFVF, D3DPOOL_DEFAULT, &vb, NULL)!=S_OK)
		return false;
	return true;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Ad3dCube::release()
{
	setTexture(NULL);
	if(vb)
	{
		vb->Release();
		vb=null;
	}
	Ad3dNode::release();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool Ad3dCube::setTexture(IDirect3DTexture9 *texture, float tcx, float tcy)
{
	if(this->texture)
		this->texture->Release();
	this->texture=texture;
	this->tcx=tcx;
	this->tcy=tcy;
	if(this->texture)
		this->texture->AddRef();
	return true;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool Ad3dCube::render(double beat, dword color)
{
	CUBE_CUSTOMVERTEX	*pVertices;

	if(vb->Lock(0, CUBE_VBUFSIZE, (void**)&pVertices, 0)==D3D_OK)	// send vertices
	{
		CUBE_CUSTOMVERTEX	*v=pVertices;
		float				uu[2];
		float				vv[2];
		int					i;
		float				xsize=this->xsize*size;
		float				ysize=this->ysize*size;
		float				zsize=this->zsize*size;

		uu[0]=tcx*0.125f;
		uu[1]=tcx-uu[0];
		vv[0]=0;
		vv[1]=tcy;
		
		for(i=0; i<12; i++)
		{
			int	nuv=(i&1)*3;
			int	j;
			for(j=0; j<3; j++)
			{
				int	p=cube_face[i][j];

				float		nx=cube_point[p][0];
				float		ny=cube_point[p][1];
				float		nz=cube_point[p][2];

				v->position.x=nx*xsize;
				v->position.y=ny*ysize;
				v->position.z=nz*zsize;

				D3DXVec3Normalize(&v->normal, &v->position);

				v->u=uu[cube_uv[nuv][0]];
				v->v=vv[cube_uv[nuv][1]];

				v->color=color;

				nuv++;
				v++;
			}
		}	
		vb->Unlock();
	}

	d3dev->SetStreamSource(0, vb, 0, sizeof(CUBE_CUSTOMVERTEX));
	d3dev->SetFVF(CUBE_D3DFVF);
	d3dev->SetTexture(0, texture);

	d3dev->SetRenderState(D3DRS_CULLMODE, D3DCULL_CCW);
	//d3dev->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
	d3dev->DrawPrimitive(D3DPT_TRIANGLELIST, 0, CUBE_NBVERTEX/3);

	return true;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Ad3dPixShader::Ad3dPixShader()
{
	char	cpath[ALIB_PATH];
	ps=null;
	effect=null;
	hColor=NULL;
	hBeat=NULL;
	hRbeat=NULL;
	hBass=NULL;
	hMedium=NULL;
	hTreeble=NULL;
	memset(hPerso, 0, sizeof(hPerso));
	memset(namePerso, 0, sizeof(namePerso));
	nperso=0;
	memset(filename, 0, sizeof(filename));

	{
		memset(cpath, 0, sizeof(cpath));
		GetModuleFileName(GetModuleHandle(null), cpath, sizeof(cpath));
		if(cpath[0])
		{
			char	*s=strrchr(cpath, '\\');
			if(s)
				*s=0;
		}
	}

	strcpy(rootdir, cpath);

	nfile=0;
	{ // add list of fx effects
		char					path[ALIB_PATH];
		struct _finddata_t		fd;
		
		strcpy(path, cpath);
		strcat(path, "\\shaders\\*.fx");

		long					h=_findfirst(path, &fd);
		if(h!=-1)
		{
			int		r=0;
			while(r!=-1)
			{
				char		str[1024];
				sprintf(str, "shaders\\%s", fd.name);
				strcpy(filename[nfile], str);
				nfile++;
				r=_findnext(h, &fd);
			}
			_findclose(h);
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Ad3dPixShader::~Ad3dPixShader()
{
	release();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool Ad3dPixShader::init(IDirect3DDevice9 *d3dev, int npix)
{	// effect (fx file)
	D3DXEFFECT_DESC		desc;
	LPD3DXBUFFER		pErrorMsgs = NULL;
	char				*fname=filename[npix];
	
	{
		D3DCAPS9 hal_caps;
		ZeroMemory(&hal_caps, sizeof(D3DCAPS9));
		if(d3dev->GetDeviceCaps(&hal_caps)!=S_OK)
			return false;
		UINT ps_major = D3DSHADER_VERSION_MAJOR(hal_caps.PixelShaderVersion);
		UINT ps_minor = D3DSHADER_VERSION_MAJOR(hal_caps.PixelShaderVersion);
		if(ps_major<2)
			return false;
 	}

	{
		char	fn[ALIB_PATH];
		strcpy(fn, rootdir);
		strcat(fn, "\\");
		strcat(fn, fname);
		if(FAILED(D3DXCreateEffectFromFile(d3dev, fn, NULL, NULL, 0, NULL, &effect, &pErrorMsgs)))
		{
			if(pErrorMsgs != NULL)
			{
				unsigned char* message = (unsigned char*)pErrorMsgs->GetBufferPointer();
				{ // save error log
					char					path[ALIB_PATH];
					FILE					*fic;
					strcpy(path, rootdir);
					strcat(path, "\\shaders\\_errors.txt");
					fic=fopen(path, "w");
					if(fic)
					{
						fprintf(fic, (char *)message);
						fclose(fic);
					}
				}
			}
			return false;
		}
	}
	
	if(FAILED(effect->GetDesc(&desc)))
		return false;
	
	{
		int					i;
		
		nperso=0;
		for(i=0; i<(int)desc.Parameters; i++)
		{
			D3DXHANDLE			hp=effect->GetParameter(NULL, i);
			D3DXPARAMETER_DESC	descp;
			
			if(!hp)
				continue;
			
			if(FAILED(effect->GetParameterDesc(hp, &descp)))
				continue;
				
			if((descp.Class==D3DXPC_VECTOR)&&(descp.Type==D3DXPT_FLOAT))
			{
				if(!strcmp(descp.Name, "color"))
				{
					hColor=hp;
					hp=NULL;
				}
			}
			else if((descp.Class==D3DXPC_SCALAR)&&(descp.Type==D3DXPT_FLOAT))
			{	
				
				if(!strcmp(descp.Name, "beat"))
					hBeat=hp;
				else if(!strcmp(descp.Name, "rbeat"))
					hRbeat=hp;
				else if(!strcmp(descp.Name, "bass"))
					hBass=hp;
				else if(!strcmp(descp.Name, "medium"))
					hMedium=hp;
				else if(!strcmp(descp.Name, "treble"))
					hTreeble=hp;
				else if(descp.Elements==0)
				{
					if(nperso<PIX_MAXINPUT)
					{
						strcpy(namePerso[nperso], descp.Name);
						hPerso[nperso++]=hp;
					}
				}
			}
		}
	}
	return true;
		/*
		{
			int	i;
			for(i=0; i<(int)desc.Functions; i++)
			{
				D3DXHANDLE			hfunc=dt->effect->GetFunction(i);
				D3DXFUNCTION_DESC	descf;
				
				if(!hfunc)
					continue;
					
				if(FAILED(dt->effect->GetFunctionDesc(hfunc, &descf)))
					continue;
			}
		}
		*/

}
void Ad3dPixShader::release()
{
	nperso=0;
	hColor=NULL;
	hBeat=NULL;
	hRbeat=NULL;
	hBass=NULL;
	hMedium=NULL;
	hTreeble=NULL;
	memset(hPerso, 0, sizeof(hPerso));
	memset(namePerso, 0, sizeof(namePerso));
	nperso=0;
	if(effect)
	{
		effect->Release();
		effect=null;
	}
	if(ps)
	{
		ps->Release();
		ps=null;
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
