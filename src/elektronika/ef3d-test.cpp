/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//	ef3f-test.CPP				(c)	YoY'03						WEB: www.aestesis.org
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include						"ef3d-test.h"
#include						"resource.h"
#include						<math.h>
#include						<d3d9.h>
#include						<D3dx9mesh.h>
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

ACI								Aef3dtestInfo::CI	= ACI("Aef3dtestInfo",	GUID(0x11111112,0xB0000010), &Aeffect3dInfo::CI, 0, NULL);
ACI								Aef3dtest::CI		= ACI("Aef3dtest",		GUID(0x11111112,0xB0000011), &Aeffect3d::CI, 0, NULL);

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

struct CUSTOMVERTEX
{
    FLOAT x, y, z, rhw; // The transformed position for the vertex.
    DWORD color;        // The vertex color.
};

class Adatatest
{
public:

	ID3DXMesh				*mesh;
	D3DMATERIAL9			*meshMat;
	LPDIRECT3DTEXTURE9		*meshTex;
	dword					nmat;
	
	Asection				section;
	char					fname[4][ALIB_PATH];
	int						anim[4];
	int						current;
	bool					bload;
	bool					repaint;
	
	Adatatest()
	{
		mesh=null;
		meshMat=null;
		meshTex=null;
		nmat=null;
		strcpy(fname[0], "NOTHING");
		strcpy(fname[1], "NOTHING");
		strcpy(fname[2], "NOTHING");
		strcpy(fname[3], "NOTHING");
		current=-1;
		anim[0]=anim[1]=anim[2]=anim[3]=0;
		bload=false;
		repaint=false;
	}
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static int						count=0;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static void init()
{
	count++;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static void end()
{
	count--;
	if(count==0)
	{
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Aef3dtest::Aef3dtest(QIID qiid, char *name, Aobject *f, int x, int y) : Aeffect3d(qiid, name, f, x, y)
{
	char str[1024];
	init();
	dt=new Adatatest();

	setTooltips("X player");
	
	sprintf(str, "%s/mesh", name);
	sel=new Aselect(MKQIID(qiid,0x887631f23766b8e2), str, this, 12, 9, 1, 4, &resource.get(MAKEINTRESOURCE(PNG_EF3D_SOURCE), "PNG"), 16, 16);
	sel->setTooltips("mesh selector");
	sel->set(0);
	sel->show(TRUE);

	sprintf(str, "%s/zoom", name);
	zoom=new Apaddle(MKQIID(qiid,0x56395a9a9fe34ec0), str, this, 220, 16, paddleYOLI16);
	zoom->setTooltips("zoom");
	zoom->set(0.5f);
	zoom->show(TRUE);

	settings(false);
	timer(100);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Aef3dtest::~Aef3dtest()
{
	delete(sel);
	delete(zoom);
	delete(dt);
	end();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool Aef3dtest::notify(Anode *o, int event, dword p)
{
	return Aobject::notify(o, event, p);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool Aef3dtest::dragdrop(int x, int y, int state, int event, void *data)
{
	switch(event)
	{
		case dragdropOVER:
		if((x>60)&&(x<200))
			return true;
		break;
		
		case dragdropDROP:
		if(state&dragdropFILE)
		{
			dt->section.enter(__FILE__,__LINE__);
			{
				int		nb=4;
				char	*s=(char *)data;
				int		n=sel->get();
			
				while(*s&&(nb--))
				{
					if(strstr(s, ".x")||strstr(s, ".X"))
					{
						strcpy(dt->fname[n], s);
						strupr(dt->fname[n]); 
						n=(n+1)&3;
					}
					else
						this->notify(this, nyERROR, (dword)"load only .X files");
					s+=strlen(s)+1;
				}
			}
			dt->bload=true;
			dt->repaint=true;
			dt->section.leave();
		}
		break;
	}
	return false;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Aef3dtest::pulse()
{
	if(dt->repaint)
		repaint();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Aef3dtest::paint(Abitmap *b)
{
	Afont	*f=alib.getFont(fontTERMINAL06);
	int		i;
	b->boxf(40, 20, 180, pos.h-20, 0xff746B58);
	dt->section.enter(__FILE__,__LINE__);
	for(i=0; i<4; i++)
	{
		char	str[1024];
		int		w,l;
		
		sprintf(str, "[%d]", i);
		w=f->getWidth(str);
		f->set(b, 60-(w>>1), 10*i+27, str, 0xff404040);
		strcpy(str, dt->fname[i]);
		l=strlen(str);
		f->set(b, 80, 10*i+27, &str[maxi(l-15, 0)], 0xff404040);
		//sprintf(str, "(%d)", dt->anim[i]);
		//w=f->getWidth(str);
		//f->set(b, 180-(w>>1), 10*i+8, str, 0xff404040);
	}
	dt->repaint=false;
	dt->section.leave();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool Aef3dtest::save(class Afile *f)
{
	char	relpath[ALIB_PATH];
	int		i;
	
	for(i=0; i<4; i++)
	{
		if(!strcmp(dt->fname[i], "NOTHING"))
		{
			f->writeString(dt->fname[i]);
		}
		else
		{
			if(f->relativePath(relpath, dt->fname[i]))
				f->writeString(relpath);
			else
				f->writeString(dt->fname[i]);
		}
	}
	return true;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool Aef3dtest::load(class Afile *f)
{
	int		i;
	char	fn[ALIB_PATH];
	char	abs[ALIB_PATH];
	for(i=0; i<4; i++)
	{
		f->readString(fn);
		if(!strcmp(fn, "NOTHING"))
		{
			strcpy(dt->fname[i], fn);
		}
		else
		{
			if(f->absoluPath(abs, fn))
				strcpy(dt->fname[i], abs);
			else
				strcpy(dt->fname[i], fn);
		}
	}
	return true;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Aef3dtest::settings(bool emergency)
{
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool Aef3dtest::loadMesh(Ad3d *d3d, char *name)
{
	clearMesh(d3d);
	{
		LPD3DXBUFFER	mat;
		D3DXMATERIAL	*d3dxMaterials;
		int				i;
		
		if(FAILED(D3DXLoadMeshFromX(name, D3DXMESH_SYSTEMMEM, d3d->d3dev, NULL, &mat, NULL, (DWORD *)&dt->nmat, &dt->mesh)))
			return false;
			
		d3dxMaterials=(D3DXMATERIAL*)mat->GetBufferPointer();

		dt->meshMat = new D3DMATERIAL9[dt->nmat];
		dt->meshTex  = new LPDIRECT3DTEXTURE9[dt->nmat];

		for(i=0; i<(int)dt->nmat; i++)
		{
			dt->meshMat[i] = d3dxMaterials[i].MatD3D;
			dt->meshMat[i].Ambient = dt->meshMat[i].Diffuse;
			if(FAILED(D3DXCreateTextureFromFile(d3d->d3dev, d3dxMaterials[i].pTextureFilename, &dt->meshTex[i])))
				dt->meshTex[i]=NULL;
		}

		mat->Release();
	}	
	return true;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Aef3dtest::clearMesh(Ad3d *d3d)
{
	dt->nmat=0;

	if(dt->meshMat)
		delete[] dt->meshMat;
		
	if(dt->meshTex)
	{
		int	i;
		for(i=0; i<(int)dt->nmat; i++)
		{
			if(dt->meshTex[i])
				dt->meshTex[i]->Release();
		}
		delete[] dt->meshTex;
	}
	
	if(dt->mesh)
		delete dt->mesh;
		
	dt->mesh=null;
	dt->meshMat=null;
	dt->meshTex=null;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool Aef3dtest::init3D(Aef3dInfo *info)
{
	dt->section.enter(__FILE__,__LINE__);
	{
		int	c=sel->get();
		dt->current=c;
		if(strcmp(dt->fname[c], "NOTHING"))
		{
			if(!loadMesh(info->d3d, dt->fname[c]))
			{
				strcpy(dt->fname[c], "NOTHING");
				dt->repaint=true;
			}
		}
		else
		{
			clearMesh(info->d3d);
		}
	}
	dt->section.leave();
	return true;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool Aef3dtest::release3D(Aef3dInfo *info)
{
	clearMesh(info->d3d);
	return true;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool Aef3dtest::action(Aef3dInfo *info)
{
	Ad3d	*d3d=info->d3d;
	{
		int	c=sel->get();
		dt->section.enter(__FILE__,__LINE__);
		if(dt->bload||(dt->current!=c))
		{
			dt->bload=false;
			dt->current=c;
			init3D(info);
		}
		dt->section.leave();
	}
	
	D3DXMATRIX	matWorld;
	D3DXMATRIX	matView;
	D3DXMATRIX	matProj;
	D3DXMATRIX	matTemp1;
	D3DXMATRIX	matTemp2;
	float		boom=(float)(info->beat-(float)(int)info->beat);
	float		zo=(zoom->get()-0.5f)*1500.f;
	int			i;

	if((int)info->beat&1)
		boom=1.f-boom;
		
	boom=(float)pow(4.f, boom);
	
	d3d->d3dev->BeginScene();

	// world matrix
	//D3DXMatrixRotationX(&matWorld, beat*1.521212f);
	D3DXMatrixRotationY(&matTemp1, (float)info->beat);
	D3DXMatrixRotationZ(&matTemp2, (float)(info->beat*1.151321));
	D3DXMatrixMultiply(&matWorld, &matTemp1, &matTemp2);
	
	d3d->d3dev->SetTransform(D3DTS_WORLD, &matWorld);
	
	// view matrix
	D3DXMatrixLookAtLH( &matView,	&D3DXVECTOR3( 0.0f, 3.0f, zo-3000.f*(1.f-info->power)-1000.0f+boom*200.f ),
									&D3DXVECTOR3( 0.0f, 0.0f, 0.0f ),
									&D3DXVECTOR3( 0.0f, 1.0f, 0.0f ) );
									
	d3d->d3dev->SetTransform(D3DTS_VIEW, &matView);
	
	// projection matrix
	D3DXMatrixPerspectiveFovLH(&matProj, D3DX_PI/4, 1.0f, 1.0f, 4000.0f );
	d3d->d3dev->SetTransform(D3DTS_PROJECTION, &matProj);	

	// light
	{
		D3DXVECTOR3 vecDir;
		D3DLIGHT9	light;
		ZeroMemory(&light, sizeof(light));
		light.Type = D3DLIGHT_DIRECTIONAL;

		light.Diffuse.r = 1.0f;
		light.Diffuse.g = 1.0f;
		light.Diffuse.b = 1.0f;

		vecDir=D3DXVECTOR3(1.f, 1.f, 0.1f);
		D3DXVec3Normalize((D3DXVECTOR3*)&light.Direction, &vecDir);

		light.Range = 1000.0f;

		d3d->d3dev->SetLight(0, &light);
	}

	d3d->d3dev->LightEnable(0, TRUE);
	d3d->d3dev->SetRenderState(D3DRS_LIGHTING, TRUE);
	d3d->d3dev->SetRenderState(D3DRS_AMBIENT, 0x00202020);
	
	d3d->d3dev->SetRenderState(D3DRS_CULLMODE, D3DCULL_CW);
    d3d->d3dev->SetRenderState(D3DRS_ZENABLE, TRUE);
    d3d->d3dev->SetRenderState(D3DRS_ZWRITEENABLE, TRUE);
	
/*	
	// render 
	d3d->d3dev->SetStreamSource(0, dt->vb, 0, sizeof(CUSTOMVERTEX));
	d3d->d3dev->SetFVF(D3DFVF_CUSTOMVERTEX);
	d3d->d3dev->DrawPrimitive(D3DPT_TRIANGLELIST, 0, 1);
*/	
	// render mesh
	for(i=0; i<(int)dt->nmat; i++)
	{
		d3d->d3dev->SetMaterial(&dt->meshMat[i]);
		d3d->d3dev->SetTexture(0, dt->meshTex[i]);
		
		d3d->d3dev->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
		switch(info->bm)
		{
			case Aef3dInfo::blendFADE:	// normal
			d3d->d3dev->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
			d3d->d3dev->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
			d3d->d3dev->SetRenderState(D3DRS_BLENDOP, D3DBLENDOP_ADD);
			break;
			
			case Aef3dInfo::blendADD:	// add
			d3d->d3dev->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
			d3d->d3dev->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ONE);
			d3d->d3dev->SetRenderState(D3DRS_BLENDOP, D3DBLENDOP_ADD);
			break;

			case Aef3dInfo::blendSUB:	// sub
			d3d->d3dev->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
			d3d->d3dev->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ONE);
			d3d->d3dev->SetRenderState(D3DRS_BLENDOP, D3DBLENDOP_REVSUBTRACT);
			break;
		}
		dt->mesh->DrawSubset(i);
	}

	d3d->d3dev->EndScene();
	return true;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool Aef3dtest::fillSurface()
{
	return false;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Aeffect3d * Aef3dtestInfo::create(QIID qiid, char *name, Aobject *father, int x, int y)
{
	return new Aef3dtest(qiid, name, father, x, y);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class Aplugz * ef3dtestGetInfo()
{
	return new Aef3dtestInfo("X player", &Aef3dtest::CI, "X player", "X player (3D mesh loader/player)");
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
