/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//	ef3f-zoom.CPP				(c)	YoY'03						WEB: www.aestesis.org
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include						"ef3d-zoom.h"
#include						"resource.h"
#include						<math.h>
#include						<d3d9.h>
#include						<D3dx9mesh.h>
#include						<assert.h>
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

ACI								Aef3dzoomInfo::CI	= ACI("Aef3dzoomInfo",	GUID(0x11111112,0xB0000030), &Aeffect3dInfo::CI, 0, NULL);
ACI								Aef3dzoom::CI		= ACI("Aef3dzoom",		GUID(0x11111112,0xB0000031), &Aeffect3d::CI, 0, NULL);

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

struct CUSTOMVERTEX
{
    FLOAT						x, y, z, rhw;
    DWORD						color;
    float						u,v;
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#define D3DFVF_CUSTOMVERTEX		(D3DFVF_XYZRHW|D3DFVF_DIFFUSE|D3DFVF_TEX1)
#define TEXSIZE					512
#define	VBUFSIZE				(sizeof(CUSTOMVERTEX)*6)

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class Adatazoom
{
public:
	IDirect3DVertexBuffer9		*vb;
	float						azoom;
	float						arot;
	float						posx;
	float						posy;
	
	Adatazoom()
	{
		vb=null;
		azoom=0.f;
		arot=0.f;
		posx=0.5f;
		posy=0.5f;
	}
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static int						count=0;
static double					angles[4];

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static void init()
{
	if(!count)
	{
		double	a=atan2(160.f, 160.f);
		angles[0]=-PI+a;
		angles[1]=-a;
		angles[2]=+a;
		angles[3]=PI-a;
	}
	count++;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static void end()
{
	count--;
	if(count==0)
	{
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Aef3dzoom::Aef3dzoom(QIID qiid, char *name, Aobject *f, int x, int y) : Aeffect3d(qiid, name, f, x, y)
{
	char	str[1024];
	init();
	dt=new Adatazoom();

	Aresobj	o=resource.get(MAKEINTRESOURCE(PNG_EF3D_ROTO), "PNG");
	back=new Abitmap(&o);

	setTooltips("roto-zoom effect");
	
	sprintf(str, "%s/zoom", name);
	zoom=new Apaddle(MKQIID(qiid, 0x4e83b26c4725e478), str, this, 30+92, (pos.h-16)>>1, paddleYOLI16);
	zoom->setTooltips("zoom");
	zoom->set(0.5f);
	zoom->show(TRUE);
	
	sprintf(str, "%s/rotation", name);
	rot=new Apaddle(MKQIID(qiid, 0x1ef8a5c5b1241314), str, this, 30+132, (pos.h-16)>>1, paddleYOLI16);
	rot->setTooltips("rotation");
	rot->set(0.5f);
	rot->show(TRUE);
	
	sprintf(str, "%s/position", name);
	zone=new Azone(MKQIID(qiid, 0xf34542eace9a1f90), str, this, 40, (pos.h-34)>>1, 34, 34, 0.5f, 0.5f);
	zone->setTooltips("position");
	zone->set(0.5f, 0.5f);
	zone->show(TRUE);
	
	settings(false);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Aef3dzoom::~Aef3dzoom()
{
	delete(rot);
	delete(zoom);
	delete(zone);
	delete(dt);
	delete(back);
	end();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool Aef3dzoom::notify(Anode *o, int event, dword p)
{
	return Aobject::notify(o, event, p);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Aef3dzoom::paint(Abitmap *b)
{
	b->set(0, 0, back, bitmapDEFAULT, bitmapDEFAULT);
	//b->boxfa(0, 0, pos.w, pos.h, 0xff000000, 0.1f);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool Aef3dzoom::save(class Afile *f)
{
	return true;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool Aef3dzoom::load(class Afile *f)
{
	return true;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Aef3dzoom::settings(bool emergency)
{
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


bool Aef3dzoom::init3D(Aef3dInfo *info)
{
	if(FAILED(info->d3d->d3dev->CreateVertexBuffer(VBUFSIZE, 0, D3DFVF_CUSTOMVERTEX, D3DPOOL_DEFAULT, &dt->vb, NULL)))
		return false;
	return true;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool Aef3dzoom::release3D(Aef3dInfo *info)
{
	if(dt->vb)
		dt->vb->Release();
	dt->vb=NULL;
	return true;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


bool Aef3dzoom::action(Aef3dInfo *info)
{
	CUSTOMVERTEX vertices[] =
	{
		{   0.0f,   0.0f, 0.5f, 1.f, 0xffffffff, 0.f, 0.f},
		{ 320.0f,   0.0f, 0.5f, 1.f, 0xffffffff, 1.f, 0.f},
		{ 320.0f, 240.0f, 0.5f, 1.f, 0xffffffff, 1.f, 1.f}, 
		{   0.0f,   0.0f, 0.5f, 1.f, 0xffffffff, 0.f, 0.f},
		{ 320.0f, 240.0f, 0.5f, 1.f, 0xffffffff, 1.f, 1.f},
		{   0.0f, 240.0f, 0.5f, 1.f, 0xffffffff, 0.f, 1.f}
	};
	Aeffect				*e=Aeffect::getEffect(this);
	Ad3d				*d3d=info->d3d;
	HRESULT				r;
	VOID				*pVertices;
	float				w=(float)d3d->w;
	float				h=(float)d3d->h;
	byte				rc,gc,bc;
	int					texType;
	float				texCx,texCy;
	IDirect3DTexture9	*tex=info->input->getTexture(&texType, &texCx, &texCy);
	
	{
		float	posx,posy;
		zone->get(&posx, &posy);
		posx=(posx-0.5f)*4.f+0.5f;
		posy=(posy-0.5f)*4.f+0.5f;
		dt->posx=dt->posx*0.5f+posx*0.5f;
		dt->posy=dt->posy*0.5f+posy*0.5f;
	}

	if(!tex)
		return false;
		
	colorRGB(&rc,&gc, &bc, info->color);
	
	dword				c=D3DCOLOR_RGBA(rc, gc, bc, (int)(info->power*255.99f));
	
	vertices[0].x=0;
	vertices[0].y=0;
	vertices[1].x=w;
	vertices[1].y=0;
	vertices[2].x=w;
	vertices[2].y=h;
	vertices[3].x=0;
	vertices[3].y=0;
	vertices[4].x=w;
	vertices[4].y=h;
	vertices[5].x=0;
	vertices[5].y=h;
	
	vertices[0].color=c;
	vertices[1].color=c;
	vertices[2].color=c;
	vertices[3].color=c;
	vertices[4].color=c;
	vertices[5].color=c;
	
	{
		float	r=rot->get()-0.5f;
		float	m=(float)fabs(r)*2.f;
		if(m<0.1f)
			dt->arot=dt->arot*(0.8f+m*2.f);
		else
			dt->arot=dt->arot*(1.f-m)+(dt->arot+r)*m;
		while(dt->arot>PI)
			dt->arot-=(float)(2*PI);
		while(dt->arot<-PI)
			dt->arot+=(float)(2*PI);
	}
	
	{
		float	u[4],v[4];
		int		i;
		//float	rv=(float)pow(3.f, (float)(3.f*((dt->azoom=dt->azoom*0.8f+(1.f-(((zoom->get()/1.2f)+0.01f))*0.2f)-0.5f))-0.3));
		float	rv=(float)(pow(3.f, 3.f*((dt->azoom=dt->azoom*0.8f+(1.f-((zoom->get()/1.2f)+0.01f))*0.2f)-0.5f))-0.3);
		//double	c=0.8*asin(fabs(sin(dt->arot)))/PI;
		rv=maxi(0.f, rv);
		for(i=0; i<4; i++)
		{
			static int px[4]={0 , 1, 1, 0};
			static int py[4]={0 , 0, 1, 1};
			float	dx=px[i]-dt->posx;
			float	dy=py[i]-dt->posy;
			float	r=(float)sqrt(dx*dx+dy*dy)*rv;
			float	a=atan2(dy, dx)+dt->arot;
			u[i]=(float)(0.5+(cos(a))*r);
			v[i]=(float)(0.5+(sin(a))*r);
		}
		vertices[0].u=u[0];
		vertices[0].v=v[0];
		vertices[1].u=u[1];
		vertices[1].v=v[1];
		vertices[2].u=u[2];
		vertices[2].v=v[2];
		vertices[3].u=u[0];
		vertices[3].v=v[0];
		vertices[4].u=u[2];
		vertices[4].v=v[2];
		vertices[5].u=u[3];
		vertices[5].v=v[3];
	}
	
	assert(VBUFSIZE==sizeof(vertices));

	if(dt->vb->Lock(0, VBUFSIZE, (void**)&pVertices, 0)==D3D_OK)
	{
		memcpy(pVertices, vertices, VBUFSIZE);
		dt->vb->Unlock();
	}
	
	d3d->d3dev->BeginScene();

	r=d3d->d3dev->SetStreamSource(0, dt->vb, 0, sizeof(CUSTOMVERTEX));
	r=d3d->d3dev->SetFVF(D3DFVF_CUSTOMVERTEX);

	r=d3d->d3dev->SetTexture(0, tex);
	tex->Release();

	r=d3d->d3dev->SetTextureStageState(0, D3DTSS_TEXCOORDINDEX, 0);

	r=d3d->d3dev->SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);
	r=d3d->d3dev->SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);
	
	r=d3d->d3dev->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
	r=d3d->d3dev->SetTextureStageState(0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE);
	r=d3d->d3dev->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_MODULATE);

	r=d3d->d3dev->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
	r=d3d->d3dev->SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);
	
	if(info->colorBoost)
		r=d3d->d3dev->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_MODULATE2X);
	else
		r=d3d->d3dev->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_MODULATE);

	r=d3d->d3dev->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
	
	switch(info->bm)
	{
		case Aef3dInfo::blendFADE:	// normal
		r=d3d->d3dev->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
		r=d3d->d3dev->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
		r=d3d->d3dev->SetRenderState(D3DRS_BLENDOP, D3DBLENDOP_ADD);
		break;
		
		case Aef3dInfo::blendADD:	// add
		r=d3d->d3dev->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
		r=d3d->d3dev->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ONE);
		r=d3d->d3dev->SetRenderState(D3DRS_BLENDOP, D3DBLENDOP_ADD);
		break;

		case Aef3dInfo::blendSUB:	// sub
		r=d3d->d3dev->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
		r=d3d->d3dev->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ONE);
		r=d3d->d3dev->SetRenderState(D3DRS_BLENDOP, D3DBLENDOP_REVSUBTRACT);
		break;
	}
	
	d3d->d3dev->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
        
	r=d3d->d3dev->DrawPrimitive(D3DPT_TRIANGLELIST, 0, 2);

	d3d->d3dev->EndScene();

	return true;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool Aef3dzoom::fillSurface()
{
	return true;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Aeffect3d * Aef3dzoomInfo::create(QIID qiid, char *name, Aobject *father, int x, int y)
{
	return new Aef3dzoom(qiid, name, father, x, y);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class Aplugz * ef3dzoomGetInfo()
{
	return new Aef3dzoomInfo("rotozoom", &Aef3dzoom::CI, "rotozoom", "rotozoom");
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
