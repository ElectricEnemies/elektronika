/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//	WMP.CPP						(c)	YoY'03						WEB: www.aestesis.org
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include						<dshow.h>
#include						<math.h>
#include						<assert.h>
#include						"resource.h"
#include						"wmpplug.h"
#include						"wmp.h"
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

ACI								AwmpInfo::CI	= ACI("AwmpInfo",	GUID(0x11111112,0x00000330), &AeffectInfo::CI, 0, NULL);
ACI								Awmp::CI		= ACI("Awmp",		GUID(0x11111112,0x00000331), &Aeffect::CI, 0, NULL);
ACI								AwmpFront::CI	= ACI("AwmpFront",	GUID(0x11111112,0x00000332), &AeffectFront::CI, 0, NULL);
ACI								AwmpBack::CI	= ACI("AwmpBack",	GUID(0x11111112,0x00000333), &AeffectBack::CI, 0, NULL);

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#define							RELEASE(pObject) if(pObject){ pObject->Release(); pObject = NULL;}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static void b2wchar(WCHAR *dest, char *src)
{
	while(*src)
		*(dest++)=*(src++);
	*dest=0;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static HRESULT UnicodeToAnsi(LPCOLESTR pszW, LPSTR* ppszA)
{
    ULONG cbAnsi, cCharacters;
    DWORD dwError;

    // If input is null then just return the same.
    if (pszW == NULL)
    {
        *ppszA = NULL;
        return NOERROR;
    }

    cCharacters = wcslen(pszW)+1;
    // Determine number of bytes to be allocated for ANSI string. An
    // ANSI string can have at most 2 bytes per character (for Double
    // Byte Character Strings.)
    cbAnsi = cCharacters*2;

    // Use of the OLE allocator is not required because the resultant
    // ANSI  string will never be passed to another COM component. You
    // can use your own allocator.
    *ppszA = (LPSTR) malloc(cbAnsi);
    if (NULL == *ppszA)
        return E_OUTOFMEMORY;

    // Convert to ANSI.
    if (0 == WideCharToMultiByte(CP_ACP, 0, pszW, cCharacters, *ppszA,
                  cbAnsi, NULL, NULL))
    {
        dwError = GetLastError();
        CoTaskMemFree(*ppszA);
        *ppszA = NULL;
        return HRESULT_FROM_WIN32(dwError);
    }
    return NOERROR;

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static int									wmpcount=0;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#define	WMPREG								"Software\\Microsoft\\MediaPlayer\\Objects\\Effects"

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

typedef struct
{
	char	name[1024];
	char	desc[1024];
	CLSID	clsid;
} ELIST;

static ELIST								elist[1024];
static int									nlist;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static void listWMP()	
{
	char		plug[1024];
	Aregistry	*reg=new Aregistry(WMPREG);
	int			n=0;
	nlist=0;
	while(reg->subEnum(n++, plug, sizeof(plug)-1))
	{
		char		key[1024];
		sprintf(key, "%s\\%s\\Properties", WMPREG, plug);
		{
			Aregistry	*r=new Aregistry(key);
			char		name[1024],desc[1024],classid[1024];
			
			r->read("classid", classid, sizeof(classid));
			r->read("name", name, sizeof(name));
			r->read("description", desc, sizeof(desc));

			{
				CLSID	clsid;
				WCHAR	wclassid[1024];
				b2wchar(wclassid, classid);
				CLSIDFromString(wclassid, &clsid);
				{
					IUnknown		*unk;
					HRESULT			hr;
					hr=CoCreateInstance(clsid, 0, CLSCTX_INPROC_SERVER, IID_IUnknown, (void**)&unk);
					if(hr==S_OK)
					{
						IWMPEffects	*plugin;
						if(unk->QueryInterface(IID_IWMPEffects, (void **)&plugin)==S_OK)
						{
							strcpy(elist[nlist].name, name);
							strcpy(elist[nlist].desc, desc);
							elist[nlist].clsid=clsid;
							nlist++;
							plugin->Release();
						}
						unk->Release();
					}
				}
			}
			
			delete(r);
		}
	}
	delete(reg);
}

// info !!!
// CLSIDFromProgID(sType)
// get the CLSID from the identifiant - ex: "Word.Basic.8" -> {00000150-5120-205-21050.....} 

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class AdataWMP
{
public:

	IWMPEffects					*plugin;
	HBITMAP						hbitmap;
	HBITMAP						hold;
	HDC							hdc;

	AdataWMP()
	{
		plugin=NULL;
		hdc=NULL;
		hbitmap=NULL;
	}
	
	~AdataWMP()
	{
		releaseDC();
		RELEASE(plugin);
	}
	
	void createDC(int w, int h)
	{
		releaseDC();
		hdc=CreateCompatibleDC(NULL);
		hbitmap=CreateBitmap(w, h, 1, 32, NULL);
		hold=(HBITMAP)SelectObject(hdc, hbitmap);
		DeleteObject(hold);
	}
	
	void releaseDC()
	{
		if(hdc)
		{
			assert(hdc&&hold&&hbitmap);
			SelectObject(hdc, hold);
			DeleteObject(hdc);
			DeleteObject(hbitmap);
		}
		hdc=NULL;
		hold=NULL;
		hbitmap=NULL;
	}
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Awmp::Awmp(QIID qiid, char *name, AeffectInfo *info, Acapsule *capsule) : Aeffect(qiid, name, info, capsule)
{
	if(!(wmpcount++))
		listWMP();
	front=new AwmpFront(qiid, "wmp front", this, 50);
	front->setTooltips("wmp wrapper");
	back=new AwmpBack(qiid, "wmp back", this, 50);
	back->setTooltips("wmp wrapper");
	dt=new AdataWMP();
	settings(false);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Awmp::~Awmp()
{
	delete(dt);
	wmpcount--;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool Awmp::load(class Afile *f)
{
	AwmpFront	*front=(AwmpFront *)this->front;
	char		drv[1024];
	char		pre[1024];
	f->readString(drv);
	f->readString(pre);
	if(front->drivers->setCurrentByName(drv))
	{
		int n=front->drivers->getCurrentData();
		front->setEffect(n);
		if(front->preset->setCurrentByName(pre))
		{
			int	n=front->preset->getCurrentData();
			front->setPreset(n);
		}
		else
		{
			if(n==666)
			{
				front->preset->setCurrentByData(666);
				front->setPreset(666);
			}
			else
			{
				front->preset->setCurrentByData(0);
				front->setPreset(0);
			}
		}
	}
	else
	{
		front->drivers->setCurrentByData(666);
		front->setEffect(666);
		front->preset->setCurrentByData(666);
	}
	return true;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool Awmp::save(class Afile *f)
{
	AwmpFront	*front=(AwmpFront *)this->front;
	Aitem		*drv=front->drivers->getCurrent();
	Aitem		*pre=front->preset->getCurrent();
	f->writeString(drv->name);
	f->writeString(pre->name);
	return true;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool Awmp::loadPreset(class Afile *f)
{
	AwmpFront	*front=(AwmpFront *)this->front;
	char		drv[1024];
	char		pre[1024];
	f->readString(drv);
	f->readString(pre);
	if(front->drivers->setCurrentByName(drv))
	{
		int n=front->drivers->getCurrentData();
		front->setEffect(n);
		if(front->preset->setCurrentByName(pre))
		{
			int	n=front->preset->getCurrentData();
			front->setPreset(n);
		}
		else
		{
			if(n==666)
			{
				front->preset->setCurrentByData(666);
				front->setPreset(666);
			}
			else
			{
				front->preset->setCurrentByData(0);
				front->setPreset(0);
			}
		}
	}
	else
	{
		front->drivers->setCurrentByData(666);
		front->setEffect(666);
		front->preset->setCurrentByData(666);
	}
	return true;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool Awmp::savePreset(class Afile *f)
{
	AwmpFront	*front=(AwmpFront *)this->front;
	Aitem		*drv=front->drivers->getCurrent();
	Aitem		*pre=front->preset->getCurrent();
	f->writeString(drv->name);
	f->writeString(pre->name);
	return true;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Awmp::settings(bool emergency)
{
	dt->createDC(getVideoWidth(), getVideoHeight());
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Awmp::action(double time, double dtime, double beat, double dbeat)
{
	AwmpBack	*back=(AwmpBack *)this->back;
	Abitmap		*b=back->out->getBitmap();
	Asample		*in=back->in;
	TimedLevel	tl;
	
	if(in->getCountConnect())
	{
		sword	smp[2*1024];
		sword	smp2[2][1024];
		double	freq[2][1024];
		int		avaible;
		int		sget;
		int		i;

		in->enter(__FILE__,__LINE__);
		avaible=in->avaible();
		avaible-=in->skip(maxi((avaible-4096)>>1, 0));
		sget=in->getBuffer(smp, NULL, NULL, NULL, 1024);
		in->leave();
		
		for(i=0; i<1024; i++)
		{
			int	n=i<<1;
			tl.waveform[0][i]=((smp[n])>>8)+128;
			tl.waveform[1][i]=((smp[n+1])>>8)+128;
			smp2[0][i]=smp[n];
			smp2[1][i]=smp[n+1];
		}
		
		Asample::calcFFT(smp2[0], freq[0]);
		Asample::calcFFT(smp2[1], freq[1]);
		
		for(i=0; i<1024; i++) 
		{
			int		n=i>>2;
			int		p=i&3;
			double	m=(0.5+sqrt((float)i));
			double	m0=(4.0-(double)p)*0.25;
			double	m1=1.0-m0;
			tl.frequency[0][i]=(byte)(mini((freq[0][n]*m0+freq[0][n+1]*m1)*m, 255.0));
			tl.frequency[1][i]=(byte)(mini((freq[0][1]*m0+freq[1][n+1]*m1)*m, 255.0));
		}
		tl.timeStamp=0;
	}

	section.enter(__FILE__,__LINE__);
	if(b)
	{
		if(dt->plugin)
		{
			RECT		r;
			
			r.top=0;
			r.left=0;
			r.right=getVideoWidth();
			r.bottom=getVideoHeight();
			
			tl.state=play_state;
			tl.timeStamp=(sqword)time;
			
			HRESULT hr=dt->plugin->Render(&tl, dt->hdc, &r);
			
			{
				BITMAPINFOHEADER	bmi;
				memset(&bmi, 0, sizeof(bmi));
				bmi.biSize=sizeof(bmi);
				bmi.biWidth=b->w;
				bmi.biHeight=b->h;
				bmi.biPlanes=1;
				bmi.biBitCount=b->nbBits;
				bmi.biCompression=BI_RGB;
				GetDIBits(dt->hdc, dt->hbitmap, 0, b->h, b->body, (BITMAPINFO *)&bmi, DIB_RGB_COLORS);
				b->flipY();
			}
			
		}
	}
	section.leave();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool AwmpFront::setEffect(int n)
{
	Awmp	*wmp=(Awmp *)effect;
	bool	b=false;
	wmp->section.enter(__FILE__,__LINE__);
	RELEASE(wmp->dt->plugin);
	if(n==666)
	{
		Aitem	*i;
		while(ipreset->fchild)
			delete(ipreset->fchild);
		i=new Aitem("[none]", "", ipreset, 666);
		preset->setCurrent(i);
	}
	else
	{
		IUnknown		*unk;
		if(CoCreateInstance(elist[n].clsid, 0, CLSCTX_INPROC_SERVER, IID_IUnknown, (void**)&unk)==S_OK)
		{
			if(unk->QueryInterface(IID_IWMPEffects, (void **)&wmp->dt->plugin)==S_OK)
			{
				while(ipreset->fchild)
					delete(ipreset->fchild);
				{
					long	np;
					if(wmp->dt->plugin->GetPresetCount(&np)==S_OK)
					{
						BSTR	bs;
						int		i;
						for(i=0; i<np; i++)
						{
							char	*title;
							wmp->dt->plugin->GetPresetTitle(i, &bs);
							UnicodeToAnsi(bs, &title);
							new Aitem(title, title, ipreset, i);
							free(title);
						}
						preset->setCurrentByData(0);
						b=setPreset(0);
					}
				}
			}
			unk->Release();
		}
	}
	wmp->section.leave();
	return b;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool AwmpFront::setPreset(int n)
{
	Awmp	*wmp=(Awmp *)effect;
	bool	b=false;
	wmp->section.enter(__FILE__,__LINE__);
	if(wmp->dt->plugin)
		b=wmp->dt->plugin->SetCurrentPreset((LONG)n)==S_OK;
	wmp->section.leave();
	return b;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

AwmpFront::AwmpFront(QIID qiid, char *name, Awmp *e, int h) : AeffectFront(qiid, name, e, h)
{
	Aresobj	o=resource.get(MAKEINTRESOURCE(PNG_WMPFRONT), "PNG");
	back=new Abitmap(&o);

	driverItems=new Aitem("wmp", "wmp");
	{
		int	i;
		for(i=0; i<nlist; i++)
			new Aitem(elist[i].name, elist[i].desc, driverItems, i);
		new Aitem("[none]", "no input", driverItems, 666);
	}
	
	drivers=new Alist("visualization plugins list", this, 53, (pos.h-16)>>1, 150, 16, driverItems);
	drivers->setCurrentByData(666);
	drivers->setTooltips("visualization plugins list");
	drivers->show(TRUE);
	
	ipreset=new Aitem("preset", "preset");
	new Aitem("[none]", "", ipreset, 666);	
	preset=new Alist("presets list", this, 309, (pos.h-16)>>1, 150, 16, ipreset);
	preset->setTooltips("presets list");
	preset->setCurrentByData(666);
	preset->show(TRUE);

	//timer(100);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

AwmpFront::~AwmpFront()
{
	delete(back);
	delete(drivers);
	delete(driverItems);
	delete(preset);
	delete(ipreset);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void AwmpFront::paint(Abitmap *b)
{
	b->set(0, 0, back, bitmapDEFAULT, bitmapDEFAULT);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool AwmpFront::notify(Anode *o, int event, dword p)
{
	switch(event)
	{
		case nyCHANGE:
		if(o==drivers)
		{
			if(!setEffect(drivers->getCurrentData()))
				drivers->setCurrentByData(666);
			return true;
		}
		else if(o==preset)
		{
			setPreset(preset->getCurrentData());
			return true;
		}
		return TRUE;
	}
	return AeffectFront::notify(o, event, p);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

AwmpBack::AwmpBack(QIID qiid, char *name, Awmp *e, int h) : AeffectBack(qiid, name, e, h)
{
	Aresobj	o=resource.get(MAKEINTRESOURCE(PNG_WMPBACK), "PNG");
	back=new Abitmap(&o);

	in=new Asample(MKQIID(qiid, 0x4047f56aa1637600), "audio in", this, pinIN, 10, 10);
	in->setTooltips("audio intput");
	in->show(TRUE);
	
	out=new Avideo(MKQIID(qiid, 0xb662b0770f95b748), "video out", this, pinOUT, pos.w-18, 10);
	out->setTooltips("video out");
	out->show(TRUE);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

AwmpBack::~AwmpBack()
{
	delete(back);
	delete(in);
	delete(out);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void AwmpBack::paint(Abitmap *b)
{
	b->set(0, 0, back, bitmapDEFAULT, bitmapDEFAULT);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Aeffect * AwmpInfo::create(QIID qiid, char *name, Acapsule *capsule)
{
	return new Awmp(qiid, name, this, capsule);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class Aplugz * wmpGetInfo()
{
	return new AwmpInfo("wmpInfo", &Awmp::CI, "wmp wrapper", "wmp wrapper module");
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Sun Mar 16 09:53:13 2003
 */
/* Compiler settings for COMobjects.idl:
    Os, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IWMPPluginUI,0x4C5E8F9F,0xAD3E,0x4bf9,0x97,0x53,0xFC,0xD3,0x0D,0x6D,0x38,0xDD);
MIDL_DEFINE_GUID(IID, IID_IWMPEffects, 0xD3984C13,0xC3CB,0x48e2,0x8B,0xE5,0x51,0x68,0x34,0x0B,0x4F,0x35);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/

